-*- buffer-read-only: t -*-
!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
This file is built by autodoc.pl extracting documentation from the C source
files.
Any changes made here will be lost!

=head1 NAME

perlintern - autogenerated documentation of purely B<internal>
Perl functions

=head1 DESCRIPTION
X<internal Perl functions> X<interpreter functions>

This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API.  In other words,
B<they are not for use in extensions>!

It has the same sections as L<perlapi>, though some may be empty.



=head1 AV Handling

=over 4

=item C<AvFILLp>
X<AvFILLp>

If the array C<av> is empty, this returns -1; otherwise it returns the maximum
value of the indices of all the array elements which are currently defined in
C<av>.  It does not handle magic, hence the C<p> private indication in its name.

=over 3

 SSize_t  AvFILLp(AV* av)

=back

=back

=for hackers
Found in file av.h

=head1 Callback Functions

There are only public API items currently in Callback Functions

=head1 Casting

There are only public API items currently in Casting

=head1 Character case changing

There are only public API items currently in Character case changing

=head1 Character classification

There are only public API items currently in Character classification

=head1 Compiler and Preprocessor information

There are only public API items currently in Compiler and Preprocessor information

=head1 Compiler directives

There are only public API items currently in Compiler directives

=head1 Compile-time scope hooks

=over 4

=item C<BhkENTRY>
X<BhkENTRY>

NOTE: C<BhkENTRY> is B<experimental> and may change or be
removed without notice.

Return an entry from the BHK structure.  C<which> is a preprocessor token
indicating which entry to return.  If the appropriate flag is not set
this will return C<NULL>.  The type of the return value depends on which
entry you ask for.

=over 3

 void *  BhkENTRY(BHK *hk, which)

=back

=back

=for hackers
Found in file op.h

=over 4

=item C<BhkFLAGS>
X<BhkFLAGS>

NOTE: C<BhkFLAGS> is B<experimental> and may change or be
removed without notice.

Return the BHK's flags.

=over 3

 U32  BhkFLAGS(BHK *hk)

=back

=back

=for hackers
Found in file op.h

=over 4

=item C<CALL_BLOCK_HOOKS>
X<CALL_BLOCK_HOOKS>

NOTE: C<CALL_BLOCK_HOOKS> is B<experimental> and may change or be
removed without notice.

Call all the registered block hooks for type C<which>.  C<which> is a
preprocessing token; the type of C<arg> depends on C<which>.

=over 3

 void  CALL_BLOCK_HOOKS(which, arg)

=back

=back

=for hackers
Found in file op.h

=head1 Concurrency

There are only public API items currently in Concurrency

=head1 COP Hint Hashes

There are only public API items currently in COP Hint Hashes

=head1 Custom Operators

=over 4

=item C<core_prototype>
X<core_prototype>

This function assigns the prototype of the named core function to C<sv>, or
to a new mortal SV if C<sv> is C<NULL>.  It returns the modified C<sv>, or
C<NULL> if the core function has no prototype.  C<code> is a code as returned
by C<keyword()>.  It must not be equal to 0.

=over 3

 SV *  core_prototype(SV *sv, const char *name, const int code,
                      int * const opnum)

=back

=back

=for hackers
Found in file op.c

=head1 CV Handling

=over 4

=item C<CvWEAKOUTSIDE>
X<CvWEAKOUTSIDE>

Each CV has a pointer, C<CvOUTSIDE()>, to its lexically enclosing
CV (if any).  Because pointers to anonymous sub prototypes are
stored in C<&> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa.  To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by C<CvOUTSIDE> in the I<one specific instance> that the parent
has a C<&> pad slot pointing back to us.  In this case, we set the
C<CvWEAKOUTSIDE> flag in the child.  This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.

There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub).  In this case, the
anonymous prototype is shared rather than being cloned.  This has the
consequence that the parent may be freed while there are still active
children, I<e.g.>,

    BEGIN { $a = sub { eval '$x' } }

In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
C<CvWEAKOUTSIDE> set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the C<eval '$x'> causes the chain of C<CvOUTSIDE>s to be followed,
and the freed BEGIN is accessed.

To avoid this, whenever a CV and its associated pad is freed, any
C<&> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's C<CvOUTSIDE> is set to point to its grandparent.  This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as C<$a> above).

One other thing to consider is that a CV may be merely undefined
rather than freed, eg C<undef &foo>.  In this case, its refcount may
not have reached zero, but we still delete its pad and its C<CvROOT> etc.
Since various children may still have their C<CvOUTSIDE> pointing at this
undefined CV, we keep its own C<CvOUTSIDE> for the time being, so that
the chain of lexical scopes is unbroken.  For example, the following
should print 123:

    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    print  $a->();

=over 3

 bool  CvWEAKOUTSIDE(CV *cv)

=back

=back

=for hackers
Found in file cv.h

=over 4

=item C<docatch>
X<docatch>

Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.

0 is used as continue inside eval,

3 is used for a die caught by an inner eval - continue inner loop

See F<cop.h>: je_mustcatch, when set at any runlevel to TRUE, means eval ops must
establish a local jmpenv to handle exception traps.

=over 3

 OP*  docatch(Perl_ppaddr_t firstpp)

=back

=back

=for hackers
Found in file pp_ctl.c

=head1 Debugging

=over 4

=item C<free_c_backtrace>
X<free_c_backtrace>

Deallocates a backtrace received from get_c_backtrace.

=over 3

 void  free_c_backtrace(Perl_c_backtrace* bt)

=back

=back

=for hackers
Found in file util.c

=over 4

=item C<get_c_backtrace>
X<get_c_backtrace>

Collects the backtrace (aka "stacktrace") into a single linear
malloced buffer, which the caller B<must> C<Perl_free_c_backtrace()>.

Scans the frames back by S<C<depth + skip>>, then drops the C<skip> innermost,
returning at most C<depth> frames.

=over 3

 Perl_c_backtrace*  get_c_backtrace(int max_depth, int skip)

=back

=back

=for hackers
Found in file util.c

=over 4

=item C<PL_DBsingle>
X<PL_DBsingle>

When Perl is run in debugging mode, with the B<-d> switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's $DB::single variable.  See
C<L</PL_DBsub>>.

On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.

=over 3

 SV *  PL_DBsingle

=back

=back

=for hackers
Found in file intrpvar.h

=over 4

=item C<PL_DBsub>
X<PL_DBsub>

When Perl is run in debugging mode, with the B<-d> switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's $DB::sub variable.  See
C<L</PL_DBsingle>>.

On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.

=over 3

 GV *  PL_DBsub

=back

=back

=for hackers
Found in file intrpvar.h

=over 4

=item C<PL_DBtrace>
X<PL_DBtrace>

Trace variable used when Perl is run in debugging mode, with the B<-d>
switch.  This is the C variable which corresponds to Perl's $DB::trace
variable.  See C<L</PL_DBsingle>>.

On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.

=over 3

 SV *  PL_DBtrace

=back

=back

=for hackers
Found in file intrpvar.h

=head1 Display functions

There are only public API items currently in Display functions

=head1 Embedding and Interpreter Cloning

=over 4

=item C<cv_dump>
X<cv_dump>

dump the contents of a CV

=over 3

 void  cv_dump(const CV *cv, const char *title)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<cv_forget_slab>
X<cv_forget_slab>

When a CV has a reference count on its slab (C<CvSLABBED>), it is responsible
for making sure it is freed.  (Hence, no two CVs should ever have a
reference count on the same slab.)  The CV only needs to reference the slab
during compilation.  Once it is compiled and C<CvROOT> attached, it has
finished its job, so it can forget the slab.

=over 3

 void  cv_forget_slab(CV *cv)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<do_dump_pad>
X<do_dump_pad>

Dump the contents of a padlist

=over 3

 void  do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist,
                   int full)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_alloc_name>
X<pad_alloc_name>

Allocates a place in the currently-compiling
pad (via L<perlapi/pad_alloc>) and
then stores a name for that entry.  C<name> is adopted and
becomes the name entry; it must already contain the name
string.  C<typestash> and C<ourstash> and the C<padadd_STATE>
flag get added to C<name>.  None of the other
processing of L<perlapi/pad_add_name_pvn>
is done.  Returns the offset of the allocated pad slot.

=over 3

 PADOFFSET  pad_alloc_name(PADNAME *name, U32 flags, HV *typestash,
                           HV *ourstash)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_block_start>
X<pad_block_start>

Update the pad compilation state variables on entry to a new block.

=over 3

 void  pad_block_start(int full)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_check_dup>
X<pad_check_dup>

Check for duplicate declarations: report any of:

     * a 'my' in the current scope with the same name;
     * an 'our' (anywhere in the pad) with the same name and the
       same stash as 'ourstash'

C<is_our> indicates that the name to check is an C<"our"> declaration.

=over 3

 void  pad_check_dup(PADNAME *name, U32 flags, const HV *ourstash)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_findlex>
X<pad_findlex>

Find a named lexical anywhere in a chain of nested pads.  Add fake entries
in the inner pads if it's found in an outer one.

Returns the offset in the bottom pad of the lex or the fake lex.
C<cv> is the CV in which to start the search, and seq is the current C<cop_seq>
to match against.  If C<warn> is true, print appropriate warnings.  The C<out_>*
vars return values, and so are pointers to where the returned values
should be stored.  C<out_capture>, if non-null, requests that the innermost
instance of the lexical is captured; C<out_name> is set to the innermost
matched pad name or fake pad name; C<out_flags> returns the flags normally
associated with the C<PARENT_FAKELEX_FLAGS> field of a fake pad name.

Note that C<pad_findlex()> is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries
as it goes.  It has to be this way
because fake names in anon prototypes have to store in C<xpadn_low> the
index into the parent pad.

=over 3

 PADOFFSET  pad_findlex(const char *namepv, STRLEN namelen,
                        U32 flags, const CV* cv, U32 seq, int warn,
                        SV** out_capture, PADNAME** out_name,
                        int *out_flags)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_fixup_inner_anons>
X<pad_fixup_inner_anons>

For any anon CVs in the pad, change C<CvOUTSIDE> of that CV from
C<old_cv> to C<new_cv> if necessary.  Needed when a newly-compiled CV has to be
moved to a pre-existing CV struct.

=over 3

 void  pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv,
                             CV *new_cv)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_free>
X<pad_free>

Free the SV at offset po in the current pad.

=over 3

 void  pad_free(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_leavemy>
X<pad_leavemy>

Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.

=over 3

 OP *  pad_leavemy()

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<padlist_dup>
X<padlist_dup>

Duplicates a pad.

=over 3

 PADLIST *  padlist_dup(PADLIST *srcpad, CLONE_PARAMS *param)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<padname_dup>
X<padname_dup>

Duplicates a pad name.

=over 3

 PADNAME *  padname_dup(PADNAME *src, CLONE_PARAMS *param)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<padnamelist_dup>
X<padnamelist_dup>

Duplicates a pad name list.

=over 3

 PADNAMELIST *  padnamelist_dup(PADNAMELIST *srcpad,
                                CLONE_PARAMS *param)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_push>
X<pad_push>

Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an C<@_> in slot zero.

=over 3

 void  pad_push(PADLIST *padlist, int depth)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_reset>
X<pad_reset>

Mark all the current temporaries for reuse

=over 3

 void  pad_reset()

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_setsv>
X<pad_setsv>

Set the value at offset C<po> in the current (compiling or executing) pad.
Use the macro C<PAD_SETSV()> rather than calling this function directly.

=over 3

 void  pad_setsv(PADOFFSET po, SV* sv)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_sv>
X<pad_sv>

Get the value at offset C<po> in the current (compiling or executing) pad.
Use macro C<PAD_SV> instead of calling this function directly.

=over 3

 SV*  pad_sv(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.c

=over 4

=item C<pad_swipe>
X<pad_swipe>

Abandon the tmp in the current pad at offset C<po> and replace with a
new one.

=over 3

 void  pad_swipe(PADOFFSET po, bool refadjust)

=back

=back

=for hackers
Found in file pad.c

=head1 Errno

=over 4

=item C<dSAVEDERRNO>
X<dSAVEDERRNO>

Declare variables needed to save C<errno> and any operating system
specific error number.

=over 3

 void  dSAVEDERRNO

=back

=back

=for hackers
Found in file perl.h

=over 4

=item C<dSAVE_ERRNO>
X<dSAVE_ERRNO>

Declare variables needed to save C<errno> and any operating system
specific error number, and save them for optional later restoration
by C<RESTORE_ERRNO>.

=over 3

 void  dSAVE_ERRNO

=back

=back

=for hackers
Found in file perl.h

=over 4

=item C<RESTORE_ERRNO>
X<RESTORE_ERRNO>

Restore C<errno> and any operating system specific error number that
was saved by C<dSAVE_ERRNO> or C<RESTORE_ERRNO>.

=over 3

 void  RESTORE_ERRNO

=back

=back

=for hackers
Found in file perl.h

=over 4

=item C<SAVE_ERRNO>
X<SAVE_ERRNO>

Save C<errno> and any operating system specific error number for
optional later restoration by C<RESTORE_ERRNO>.  Requires
C<dSAVEDERRNO> or C<dSAVE_ERRNO> in scope.

=over 3

 void  SAVE_ERRNO

=back

=back

=for hackers
Found in file perl.h

=over 4

=item C<SETERRNO>
X<SETERRNO>

Set C<errno>, and on VMS set C<vaxc$errno>.

=over 3

 void  SETERRNO(int errcode, int vmserrcode)

=back

=back

=for hackers
Found in file perl.h

=head1 Exception Handling (simple) Macros

There are only public API items currently in Exception Handling (simple) Macros

=head1 Filesystem configuration values

There are only public API items currently in Filesystem configuration values

=head1 Floating point configuration values

There are only public API items currently in Floating point configuration values

=head1 Formats

There are only public API items currently in Formats

=head1 General Configuration

There are only public API items currently in General Configuration

=head1 Global Variables

There are only public API items currently in Global Variables

=head1 GV Handling

=over 4

=item C<gv_stashsvpvn_cached>
X<gv_stashsvpvn_cached>

Returns a pointer to the stash for a specified package, possibly
cached.  Implements both L<perlapi/C<gv_stashpvn>> and
L<perlapi/C<gv_stashsv>>.

Requires one of either C<namesv> or C<namepv> to be non-null.

If the flag C<GV_CACHE_ONLY> is set, return the stash only if found in the
cache; see L<perlapi/C<gv_stashpvn>> for details on the other C<flags>.

Note it is strongly preferred for C<namesv> to be non-null, for performance
reasons.

=over 3

 HV*  gv_stashsvpvn_cached(SV *namesv, const char* name,
                           U32 namelen, I32 flags)

=back

=back

=for hackers
Found in file gv.c

=over 4

=item C<gv_try_downgrade>
X<gv_try_downgrade>

NOTE: C<gv_try_downgrade> is B<experimental> and may change or be
removed without notice.

If the typeglob C<gv> can be expressed more succinctly, by having
something other than a real GV in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that C<gv>
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a GV has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real GV isn't required after all.

If C<gv> is a completely empty typeglob, it is deleted from the stash.

If C<gv> is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.

=over 3

 void  gv_try_downgrade(GV* gv)

=back

=back

=for hackers
Found in file gv.c

=head1 Hook manipulation

There are only public API items currently in Hook manipulation

=head1 HV Handling

=over 4

=item C<hv_ename_add>
X<hv_ename_add>

Adds a name to a stash's internal list of effective names.  See
C<L</hv_ename_delete>>.

This is called when a stash is assigned to a new location in the symbol
table.

=over 3

 void  hv_ename_add(HV *hv, const char *name, U32 len, U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<hv_ename_delete>
X<hv_ename_delete>

Removes a name from a stash's internal list of effective names.  If this is
the name returned by C<HvENAME>, then another name in the list will take
its place (C<HvENAME> will use it).

This is called when a stash is deleted from the symbol table.

=over 3

 void  hv_ename_delete(HV *hv, const char *name, U32 len,
                       U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_chain_2hv>
X<refcounted_he_chain_2hv>

Generates and returns a C<HV *> representing the content of a
C<refcounted_he> chain.
C<flags> is currently unused and must be zero.

=over 3

 HV *  refcounted_he_chain_2hv(const struct refcounted_he *c,
                               U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_fetch_pv>
X<refcounted_he_fetch_pv>

Like L</refcounted_he_fetch_pvn>, but takes a nul-terminated string
instead of a string/length pair.

=over 3

 SV *  refcounted_he_fetch_pv(const struct refcounted_he *chain,
                              const char *key, U32 hash, U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_fetch_pvn>
X<refcounted_he_fetch_pvn>

Search along a C<refcounted_he> chain for an entry with the key specified
by C<keypv> and C<keylen>.  If C<flags> has the C<REFCOUNTED_HE_KEY_UTF8>
bit set, the key octets are interpreted as UTF-8, otherwise they
are interpreted as Latin-1.  C<hash> is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or C<&PL_sv_placeholder>
if there is no value associated with the key.

=over 3

 SV *  refcounted_he_fetch_pvn(const struct refcounted_he *chain,
                               const char *keypv, STRLEN keylen,
                               U32 hash, U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_fetch_pvs>
X<refcounted_he_fetch_pvs>

Like L</refcounted_he_fetch_pvn>, but takes a literal string
instead of a string/length pair, and no precomputed hash.

=over 3

 SV *  refcounted_he_fetch_pvs(const struct refcounted_he *chain,
                               "key", U32 flags)

=back

=back

=for hackers
Found in file hv.h

=over 4

=item C<refcounted_he_fetch_sv>
X<refcounted_he_fetch_sv>

Like L</refcounted_he_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=over 3

 SV *  refcounted_he_fetch_sv(const struct refcounted_he *chain,
                              SV *key, U32 hash, U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_free>
X<refcounted_he_free>

Decrements the reference count of a C<refcounted_he> by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent C<refcounted_he>'s
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.

=over 3

 void  refcounted_he_free(struct refcounted_he *he)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_inc>
X<refcounted_he_inc>

Increment the reference count of a C<refcounted_he>.  The pointer to the
C<refcounted_he> is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.

=over 3

 struct refcounted_he *  refcounted_he_inc(
                                          struct refcounted_he *he)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_new_pv>
X<refcounted_he_new_pv>

Like L</refcounted_he_new_pvn>, but takes a nul-terminated string instead
of a string/length pair.

=over 3

 struct refcounted_he *  refcounted_he_new_pv(
                                      struct refcounted_he *parent,
                                      const char *key, U32 hash,
                                      SV *value, U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_new_pvn>
X<refcounted_he_new_pvn>

Creates a new C<refcounted_he>.  This consists of a single key/value
pair and a reference to an existing C<refcounted_he> chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.

The new key is specified by C<keypv> and C<keylen>.  If C<flags> has
the C<REFCOUNTED_HE_KEY_UTF8> bit set, the key octets are interpreted
as UTF-8, otherwise they are interpreted as Latin-1.  C<hash> is
a precomputed hash of the key string, or zero if it has not been
precomputed.

C<value> is the scalar value to store for this key.  C<value> is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the C<refcounted_he>.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
C<value> may be either null or C<&PL_sv_placeholder> to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.

C<parent> points to the rest of the C<refcounted_he> chain to be
attached to the new C<refcounted_he>.  This function takes ownership
of one reference to C<parent>, and returns one reference to the new
C<refcounted_he>.

=over 3

 struct refcounted_he *  refcounted_he_new_pvn(
                                      struct refcounted_he *parent,
                                      const char *keypv,
                                      STRLEN keylen, U32 hash,
                                      SV *value, U32 flags)

=back

=back

=for hackers
Found in file hv.c

=over 4

=item C<refcounted_he_new_pvs>
X<refcounted_he_new_pvs>

Like L</refcounted_he_new_pvn>, but takes a literal string
instead of a string/length pair, and no precomputed hash.

=over 3

 struct refcounted_he *  refcounted_he_new_pvs(
                                      struct refcounted_he *parent,
                                      "key", SV *value, U32 flags)

=back

=back

=for hackers
Found in file hv.h

=over 4

=item C<refcounted_he_new_sv>
X<refcounted_he_new_sv>

Like L</refcounted_he_new_pvn>, but takes a Perl scalar instead of a
string/length pair.

=over 3

 struct refcounted_he *  refcounted_he_new_sv(
                                      struct refcounted_he *parent,
                                      SV *key, U32 hash, SV *value,
                                      U32 flags)

=back

=back

=for hackers
Found in file hv.c

=head1 Input/Output

=over 4

=item C<PL_last_in_gv>
X<PL_last_in_gv>

The GV which was last used for a filehandle input operation.  (C<< <FH> >>)

On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.

=over 3

 GV*  PL_last_in_gv

=back

=back

=for hackers
Found in file intrpvar.h

=over 4

=item C<PL_ofsgv>
X<PL_ofsgv>

The glob containing the output field separator - C<*,> in Perl space.

On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.

=over 3

 GV*  PL_ofsgv

=back

=back

=for hackers
Found in file intrpvar.h

=over 4

=item C<PL_rs>
X<PL_rs>

The input record separator - C<$/> in Perl space.

On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.

=over 3

 SV*  PL_rs

=back

=back

=for hackers
Found in file intrpvar.h

=over 4

=item C<start_glob>
X<start_glob>

NOTE: C<start_glob> is B<experimental> and may change or be
removed without notice.

Function called by C<do_readline> to spawn a glob (or do the glob inside
perl on VMS).  This code used to be inline, but now perl uses C<File::Glob>
this glob starter is only used by miniperl during the build process,
or when PERL_EXTERNAL_GLOB is defined.
Moving it away shrinks F<pp_hot.c>; shrinking F<pp_hot.c> helps speed perl up.

NOTE: C<start_glob> must be explicitly called as
C<Perl_start_glob>
with an C<aTHX_> parameter.

=over 3

 PerlIO*  Perl_start_glob(pTHX_ SV *tmpglob, IO *io)

=back

=back

=for hackers
Found in file doio.c

=head1 Integer configuration values

There are only public API items currently in Integer configuration values

=head1 Lexer interface

=over 4

=item C<validate_proto>
X<validate_proto>

NOTE: C<validate_proto> is B<experimental> and may change or be
removed without notice.

This function performs syntax checking on a prototype, C<proto>.
If C<warn> is true, any illegal characters or mismatched brackets
will trigger illegalproto warnings, declaring that they were
detected in the prototype for C<name>.

The return value is C<true> if this is a valid prototype, and
C<false> if it is not, regardless of whether C<warn> was C<true> or
C<false>.

Note that C<NULL> is a valid C<proto> and will always return C<true>.

=over 3

 bool  validate_proto(SV *name, SV *proto, bool warn,
                      bool curstash)

=back

=back

=for hackers
Found in file toke.c

=head1 Locales

There are only public API items currently in Locales

=head1 Magic

=over 4

=item C<magic_clearhint>
X<magic_clearhint>

Triggered by a delete from C<%^H>, records the key to
C<PL_compiling.cop_hints_hash>.

=over 3

 int  magic_clearhint(SV* sv, MAGIC* mg)

=back

=back

=for hackers
Found in file mg.c

=over 4

=item C<magic_clearhints>
X<magic_clearhints>

Triggered by clearing C<%^H>, resets C<PL_compiling.cop_hints_hash>.

=over 3

 int  magic_clearhints(SV* sv, MAGIC* mg)

=back

=back

=for hackers
Found in file mg.c

=over 4

=item C<magic_methcall>
X<magic_methcall>

Invoke a magic method (like FETCH).

C<sv> and C<mg> are the tied thingy and the tie magic.

C<meth> is the name of the method to call.

C<argc> is the number of args (in addition to $self) to pass to the method.

The C<flags> can be:

    G_DISCARD     invoke method with G_DISCARD flag and don't
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef

The arguments themselves are any values following the C<flags> argument.

Returns the SV (if any) returned by the method, or C<NULL> on failure.

NOTE: C<magic_methcall> must be explicitly called as
C<Perl_magic_methcall>
with an C<aTHX_> parameter.

=over 3

 SV*  Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth,
                          U32 flags, U32 argc, ...)

=back

=back

=for hackers
Found in file mg.c

=over 4

=item C<magic_sethint>
X<magic_sethint>

Triggered by a store to C<%^H>, records the key/value pair to
C<PL_compiling.cop_hints_hash>.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.

=over 3

 int  magic_sethint(SV* sv, MAGIC* mg)

=back

=back

=for hackers
Found in file mg.c

=over 4

=item C<mg_localize>
X<mg_localize>

Copy some of the magic from an existing SV to new localized version of that
SV.  Container magic (I<e.g.>, C<%ENV>, C<$1>, C<tie>)
gets copied, value magic doesn't (I<e.g.>,
C<taint>, C<pos>).

If C<setmagic> is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. S<C<'local $x = $y'>>),
and that will handle the magic.

=over 3

 void  mg_localize(SV* sv, SV* nsv, bool setmagic)

=back

=back

=for hackers
Found in file mg.c

=head1 Memory Management

There are only public API items currently in Memory Management

=head1 MRO

=over 4

=item C<mro_get_linear_isa_dfs>
X<mro_get_linear_isa_dfs>

Returns the Depth-First Search linearization of C<@ISA>
the given stash.  The return value is a read-only AV*.
C<level> should be 0 (it is used internally in this
function's recursion).

You are responsible for C<SvREFCNT_inc()> on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).

=over 3

 AV*  mro_get_linear_isa_dfs(HV* stash, U32 level)

=back

=back

=for hackers
Found in file mro_core.c

=over 4

=item C<mro_isa_changed_in>
X<mro_isa_changed_in>

Takes the necessary steps (cache invalidations, mostly)
when the C<@ISA> of the given package has changed.  Invoked
by the C<setisa> magic, should not need to invoke directly.

=over 3

 void  mro_isa_changed_in(HV* stash)

=back

=back

=for hackers
Found in file mro_core.c

=over 4

=item C<mro_package_moved>
X<mro_package_moved>

Call this function to signal to a stash that it has been assigned to
another spot in the stash hierarchy.  C<stash> is the stash that has been
assigned.  C<oldstash> is the stash it replaces, if any.  C<gv> is the glob
that is actually being assigned to.

This can also be called with a null first argument to
indicate that C<oldstash> has been deleted.

This function invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those, including
non-existent packages that have corresponding entries in C<stash>.

It also sets the effective names (C<HvENAME>) on all the stashes as
appropriate.

If the C<gv> is present and is not in the symbol table, then this function
simply returns.  This checked will be skipped if C<flags & 1>.

=over 3

 void  mro_package_moved(HV * const stash, HV * const oldstash,
                         const GV * const gv, U32 flags)

=back

=back

=for hackers
Found in file mro_core.c

=head1 Multicall Functions

There are only public API items currently in Multicall Functions

=head1 Numeric Functions

=over 4

=item C<grok_atoUV>
X<grok_atoUV>

parse a string, looking for a decimal unsigned integer.

On entry, C<pv> points to the beginning of the string;
C<valptr> points to a UV that will receive the converted value, if found;
C<endptr> is either NULL or points to a variable that points to one byte
beyond the point in C<pv> that this routine should examine.
If C<endptr> is NULL, C<pv> is assumed to be NUL-terminated.

Returns FALSE if C<pv> doesn't represent a valid unsigned integer value (with
no leading zeros).  Otherwise it returns TRUE, and sets C<*valptr> to that
value.

If you constrain the portion of C<pv> that is looked at by this function (by
passing a non-NULL C<endptr>), and if the intial bytes of that portion form a
valid value, it will return TRUE, setting C<*endptr> to the byte following the
final digit of the value.  But if there is no constraint at what's looked at,
all of C<pv> must be valid in order for TRUE to be returned.  C<*endptr> is
unchanged from its value on input if FALSE is returned;

The only characters this accepts are the decimal digits '0'..'9'.

As opposed to L<atoi(3)> or L<strtol(3)>, C<grok_atoUV> does NOT allow optional
leading whitespace, nor negative inputs.  If such features are required, the
calling code needs to explicitly implement those.

Note that this function returns FALSE for inputs that would overflow a UV,
or have leading zeros.  Thus a single C<0> is accepted, but not C<00> nor
C<01>, C<002>, I<etc>.

Background: C<atoi> has severe problems with illegal inputs, it cannot be
used for incremental parsing, and therefore should be avoided
C<atoi> and C<strtol> are also affected by locale settings, which can also be
seen as a bug (global state controlled by user environment).

=over 3

 bool  grok_atoUV(const char* pv, UV* valptr, const char** endptr)

=back

=back

=for hackers
Found in file numeric.c

=over 4

=item C<isinfnansv>
X<isinfnansv>

Checks whether the argument would be either an infinity or C<NaN> when used
as a number, but is careful not to trigger non-numeric or uninitialized
warnings.  it assumes the caller has done C<SvGETMAGIC(sv)> already.

=over 3

 bool  isinfnansv(SV *sv)

=back

=back

=for hackers
Found in file numeric.c

=head1 Optree construction

There are only public API items currently in Optree construction

=head1 Optree Manipulation Functions

=over 4

=item C<finalize_optree>
X<finalize_optree>

This function finalizes the optree.  Should be called directly after
the complete optree is built.  It does some additional
checking which can't be done in the normal C<ck_>xxx functions and makes
the tree thread-safe.

=over 3

 void  finalize_optree(OP* o)

=back

=back

=for hackers
Found in file op.c

=over 4

=item C<newATTRSUB_x>
X<newATTRSUB_x>

Construct a Perl subroutine, also performing some surrounding jobs.

This function is expected to be called in a Perl compilation context,
and some aspects of the subroutine are taken from global variables
associated with compilation.  In particular, C<PL_compcv> represents
the subroutine that is currently being compiled.  It must be non-null
when this function is called, and some aspects of the subroutine being
constructed are taken from it.  The constructed subroutine may actually
be a reuse of the C<PL_compcv> object, but will not necessarily be so.

If C<block> is null then the subroutine will have no body, and for the
time being it will be an error to call it.  This represents a forward
subroutine declaration such as S<C<sub foo ($$);>>.  If C<block> is
non-null then it provides the Perl code of the subroutine body, which
will be executed when the subroutine is called.  This body includes
any argument unwrapping code resulting from a subroutine signature or
similar.  The pad use of the code must correspond to the pad attached
to C<PL_compcv>.  The code is not expected to include a C<leavesub> or
C<leavesublv> op; this function will add such an op.  C<block> is consumed
by this function and will become part of the constructed subroutine.

C<proto> specifies the subroutine's prototype, unless one is supplied
as an attribute (see below).  If C<proto> is null, then the subroutine
will not have a prototype.  If C<proto> is non-null, it must point to a
C<const> op whose value is a string, and the subroutine will have that
string as its prototype.  If a prototype is supplied as an attribute, the
attribute takes precedence over C<proto>, but in that case C<proto> should
preferably be null.  In any case, C<proto> is consumed by this function.

C<attrs> supplies attributes to be applied the subroutine.  A handful of
attributes take effect by built-in means, being applied to C<PL_compcv>
immediately when seen.  Other attributes are collected up and attached
to the subroutine by this route.  C<attrs> may be null to supply no
attributes, or point to a C<const> op for a single attribute, or point
to a C<list> op whose children apart from the C<pushmark> are C<const>
ops for one or more attributes.  Each C<const> op must be a string,
giving the attribute name optionally followed by parenthesised arguments,
in the manner in which attributes appear in Perl source.  The attributes
will be applied to the sub by this function.  C<attrs> is consumed by
this function.

If C<o_is_gv> is false and C<o> is null, then the subroutine will
be anonymous.  If C<o_is_gv> is false and C<o> is non-null, then C<o>
must point to a C<const> OP, which will be consumed by this function,
and its string value supplies a name for the subroutine.  The name may
be qualified or unqualified, and if it is unqualified then a default
stash will be selected in some manner.  If C<o_is_gv> is true, then C<o>
doesn't point to an C<OP> at all, but is instead a cast pointer to a C<GV>
by which the subroutine will be named.

If there is already a subroutine of the specified name, then the new
sub will either replace the existing one in the glob or be merged with
the existing one.  A warning may be generated about redefinition.

If the subroutine has one of a few special names, such as C<BEGIN> or
C<END>, then it will be claimed by the appropriate queue for automatic
running of phase-related subroutines.  In this case the relevant glob will
be left not containing any subroutine, even if it did contain one before.
In the case of C<BEGIN>, the subroutine will be executed and the reference
to it disposed of before this function returns.

The function returns a pointer to the constructed subroutine.  If the sub
is anonymous then ownership of one counted reference to the subroutine
is transferred to the caller.  If the sub is named then the caller does
not get ownership of a reference.  In most such cases, where the sub
has a non-phase name, the sub will be alive at the point it is returned
by virtue of being contained in the glob that names it.  A phase-named
subroutine will usually be alive by virtue of the reference owned by the
phase's automatic run queue.  But a C<BEGIN> subroutine, having already
been executed, will quite likely have been destroyed already by the
time this function returns, making it erroneous for the caller to make
any use of the returned pointer.  It is the caller's responsibility to
ensure that it knows which of these situations applies.

=over 3

 CV*  newATTRSUB_x(I32 floor, OP *o, OP *proto, OP *attrs,
                   OP *block, bool o_is_gv)

=back

=back

=for hackers
Found in file op.c

=over 4

=item C<newXS_len_flags>
X<newXS_len_flags>

Construct an XS subroutine, also performing some surrounding jobs.

The subroutine will have the entry point C<subaddr>.  It will have
the prototype specified by the nul-terminated string C<proto>, or
no prototype if C<proto> is null.  The prototype string is copied;
the caller can mutate the supplied string afterwards.  If C<filename>
is non-null, it must be a nul-terminated filename, and the subroutine
will have its C<CvFILE> set accordingly.  By default C<CvFILE> is set to
point directly to the supplied string, which must be static.  If C<flags>
has the C<XS_DYNAMIC_FILENAME> bit set, then a copy of the string will
be taken instead.

Other aspects of the subroutine will be left in their default state.
If anything else needs to be done to the subroutine for it to function
correctly, it is the caller's responsibility to do that after this
function has constructed it.  However, beware of the subroutine
potentially being destroyed before this function returns, as described
below.

If C<name> is null then the subroutine will be anonymous, with its
C<CvGV> referring to an C<__ANON__> glob.  If C<name> is non-null then the
subroutine will be named accordingly, referenced by the appropriate glob.
C<name> is a string of length C<len> bytes giving a sigilless symbol name,
in UTF-8 if C<flags> has the C<SVf_UTF8> bit set and in Latin-1 otherwise.
The name may be either qualified or unqualified, with the stash defaulting
in the same manner as for C<gv_fetchpvn_flags>.  C<flags> may contain
flag bits understood by C<gv_fetchpvn_flags> with the same meaning as
they have there, such as C<GV_ADDWARN>.  The symbol is always added to
the stash if necessary, with C<GV_ADDMULTI> semantics.

If there is already a subroutine of the specified name, then the new sub
will replace the existing one in the glob.  A warning may be generated
about the redefinition.  If the old subroutine was C<CvCONST> then the
decision about whether to warn is influenced by an expectation about
whether the new subroutine will become a constant of similar value.
That expectation is determined by C<const_svp>.  (Note that the call to
this function doesn't make the new subroutine C<CvCONST> in any case;
that is left to the caller.)  If C<const_svp> is null then it indicates
that the new subroutine will not become a constant.  If C<const_svp>
is non-null then it indicates that the new subroutine will become a
constant, and it points to an C<SV*> that provides the constant value
that the subroutine will have.

If the subroutine has one of a few special names, such as C<BEGIN> or
C<END>, then it will be claimed by the appropriate queue for automatic
running of phase-related subroutines.  In this case the relevant glob will
be left not containing any subroutine, even if it did contain one before.
In the case of C<BEGIN>, the subroutine will be executed and the reference
to it disposed of before this function returns, and also before its
prototype is set.  If a C<BEGIN> subroutine would not be sufficiently
constructed by this function to be ready for execution then the caller
must prevent this happening by giving the subroutine a different name.

The function returns a pointer to the constructed subroutine.  If the sub
is anonymous then ownership of one counted reference to the subroutine
is transferred to the caller.  If the sub is named then the caller does
not get ownership of a reference.  In most such cases, where the sub
has a non-phase name, the sub will be alive at the point it is returned
by virtue of being contained in the glob that names it.  A phase-named
subroutine will usually be alive by virtue of the reference owned by the
phase's automatic run queue.  But a C<BEGIN> subroutine, having already
been executed, will quite likely have been destroyed already by the
time this function returns, making it erroneous for the caller to make
any use of the returned pointer.  It is the caller's responsibility to
ensure that it knows which of these situations applies.

=over 3

 CV *  newXS_len_flags(const char *name, STRLEN len,
                       XSUBADDR_t subaddr,
                       const char *const filename,
                       const char *const proto, SV **const_svp,
                       U32 flags)

=back

=back

=for hackers
Found in file op.c

=over 4

=item C<optimize_optree>
X<optimize_optree>

This function applies some optimisations to the optree in top-down order.
It is called before the peephole optimizer, which processes ops in
execution order. Note that finalize_optree() also does a top-down scan,
but is called *after* the peephole optimizer.

=over 3

 void  optimize_optree(OP* o)

=back

=back

=for hackers
Found in file op.c

=over 4

=item C<traverse_op_tree>
X<traverse_op_tree>

Return the next op in a depth-first traversal of the op tree,
returning NULL when the traversal is complete.

The initial call must supply the root of the tree as both top and o.

For now it's static, but it may be exposed to the API in the future.

=over 3

 OP*  traverse_op_tree(OP* top, OP* o)

=back

=back

=for hackers
Found in file op.c

=head1 Pack and Unpack

There are only public API items currently in Pack and Unpack

=head1 Pad Data Structures

=over 4

=item C<CX_CURPAD_SAVE>
X<CX_CURPAD_SAVE>

Save the current pad in the given context block structure.

=over 3

 void  CX_CURPAD_SAVE(struct context)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<CX_CURPAD_SV>
X<CX_CURPAD_SV>

Access the SV at offset C<po> in the saved current pad in the given
context block structure (can be used as an lvalue).

=over 3

 SV *  CX_CURPAD_SV(struct context, PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_BASE_SV>
X<PAD_BASE_SV>

Get the value from slot C<po> in the base (DEPTH=1) pad of a padlist

=over 3

 SV *  PAD_BASE_SV(PADLIST padlist, PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_CLONE_VARS>
X<PAD_CLONE_VARS>

Clone the state variables associated with running and compiling pads.

=over 3

 void  PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                      CLONE_PARAMS* param)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_COMPNAME_FLAGS>
X<PAD_COMPNAME_FLAGS>

Return the flags for the current compiling pad name
at offset C<po>.  Assumes a valid slot entry.

=over 3

 U32  PAD_COMPNAME_FLAGS(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_COMPNAME_GEN>
X<PAD_COMPNAME_GEN>

The generation number of the name at offset C<po> in the current
compiling pad (lvalue).

=over 3

 STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_COMPNAME_GEN_set>
X<PAD_COMPNAME_GEN_set>

Sets the generation number of the name at offset C<po> in the current
ling pad (lvalue) to C<gen>.

=over 3

 STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_COMPNAME_OURSTASH>
X<PAD_COMPNAME_OURSTASH>

Return the stash associated with an C<our> variable.
Assumes the slot entry is a valid C<our> lexical.

=over 3

 HV *  PAD_COMPNAME_OURSTASH(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_COMPNAME_PV>
X<PAD_COMPNAME_PV>

Return the name of the current compiling pad name
at offset C<po>.  Assumes a valid slot entry.

=over 3

 char *  PAD_COMPNAME_PV(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_COMPNAME_TYPE>
X<PAD_COMPNAME_TYPE>

Return the type (stash) of the current compiling pad name at offset
C<po>.  Must be a valid name.  Returns null if not typed.

=over 3

 HV *  PAD_COMPNAME_TYPE(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PadnameIsOUR>
X<PadnameIsOUR>

Whether this is an "our" variable.

=over 3

 bool  PadnameIsOUR(PADNAME * pn)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PadnameIsSTATE>
X<PadnameIsSTATE>

Whether this is a "state" variable.

=over 3

 bool  PadnameIsSTATE(PADNAME * pn)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PadnameOURSTASH>
X<PadnameOURSTASH>

The stash in which this "our" variable was declared.

=over 3

 HV *  PadnameOURSTASH(PADNAME * pn)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PadnameOUTER>
X<PadnameOUTER>

Whether this entry belongs to an outer pad.  Entries for which this is true
are often referred to as 'fake'.

=over 3

 bool  PadnameOUTER(PADNAME * pn)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PadnameTYPE>
X<PadnameTYPE>

The stash associated with a typed lexical.  This returns the C<%Foo::> hash
for C<my Foo $bar>.

=over 3

 HV *  PadnameTYPE(PADNAME * pn)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_RESTORE_LOCAL>
X<PAD_RESTORE_LOCAL>

Restore the old pad saved into the local variable C<opad> by C<PAD_SAVE_LOCAL()>

=over 3

 void  PAD_RESTORE_LOCAL(PAD *opad)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_SAVE_LOCAL>
X<PAD_SAVE_LOCAL>

Save the current pad to the local variable C<opad>, then make the
current pad equal to C<npad>

=over 3

 void  PAD_SAVE_LOCAL(PAD *opad, PAD *npad)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_SAVE_SETNULLPAD>
X<PAD_SAVE_SETNULLPAD>

Save the current pad then set it to null.

=over 3

 void  PAD_SAVE_SETNULLPAD()

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_SETSV>
X<PAD_SETSV>

Set the slot at offset C<po> in the current pad to C<sv>

=over 3

 SV *  PAD_SETSV(PADOFFSET po, SV* sv)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_SET_CUR>
X<PAD_SET_CUR>

Set the current pad to be pad C<n> in the padlist, saving
the previous current pad.  NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with

    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);

=over 3

 void  PAD_SET_CUR(PADLIST padlist, I32 n)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_SET_CUR_NOSAVE>
X<PAD_SET_CUR_NOSAVE>

like PAD_SET_CUR, but without the save

=over 3

 void  PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_SV>
X<PAD_SV>

Get the value at offset C<po> in the current pad

=over 3

 SV *  PAD_SV(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<PAD_SVl>
X<PAD_SVl>

Lightweight and lvalue version of C<PAD_SV>.
Get or set the value at offset C<po> in the current pad.
Unlike C<PAD_SV>, does not print diagnostics with -DX.
For internal use only.

=over 3

 SV *  PAD_SVl(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<SAVECLEARSV>
X<SAVECLEARSV>

Clear the pointed to pad value on scope exit.  (i.e. the runtime action of
C<my>)

=over 3

 void  SAVECLEARSV(SV **svp)

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<SAVECOMPPAD>
X<SAVECOMPPAD>

save C<PL_comppad> and C<PL_curpad>

=over 3

 void  SAVECOMPPAD()

=back

=back

=for hackers
Found in file pad.h

=over 4

=item C<SAVEPADSV>
X<SAVEPADSV>

Save a pad slot (used to restore after an iteration)

=over 3

 void  SAVEPADSV(PADOFFSET po)

=back

=back

=for hackers
Found in file pad.h

=head1 Password and Group access

There are only public API items currently in Password and Group access

=head1 Paths to system commands

There are only public API items currently in Paths to system commands

=head1 Prototype information

There are only public API items currently in Prototype information

=head1 REGEXP Functions

There are only public API items currently in REGEXP Functions

=head1 Signals

There are only public API items currently in Signals

=head1 Site configuration

There are only public API items currently in Site configuration

=head1 Sockets configuration values

There are only public API items currently in Sockets configuration values

=head1 Source Filters

There are only public API items currently in Source Filters

=head1 Stack Manipulation Macros

=over 4

=item C<djSP>
X<djSP>

Declare Just C<SP>.  This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<L<perlapi/SP>>.  (Available for backward source code compatibility with
the old (Perl 5.005) thread model.)

=over 3

   djSP();

=back

=back

=for hackers
Found in file pp.h

=over 4

=item C<LVRET>
X<LVRET>

True if this op will be the return value of an lvalue subroutine

=back

=for hackers
Found in file pp.h

=head1 String Handling

=over 4

=item C<delimcpy_no_escape>
X<delimcpy_no_escape>

Copy a source buffer to a destination buffer, stopping at (but not including)
the first occurrence in the source of the delimiter byte, C<delim>.  The source
is the bytes between S<C<from> and C<from_end> - 1>.  Similarly, the dest is
C<to> up to C<to_end>.

The number of bytes copied is written to C<*retlen>.

Returns the position of C<delim> in the C<from> buffer, but if there is no
such occurrence before C<from_end>, then C<from_end> is returned, and the entire
buffer S<C<from> .. C<from_end> - 1> is copied.

If there is room in the destination available after the copy, an extra
terminating safety C<NUL> byte is appended (not included in the returned
length).

The error case is if the destination buffer is not large enough to accommodate
everything that should be copied.  In this situation, a value larger than
S<C<to_end> - C<to>> is written to C<*retlen>, and as much of the source as
fits will be written to the destination.  Not having room for the safety C<NUL>
is not considered an error.

=over 3

 char*  delimcpy_no_escape(char* to, const char* to_end,
                           const char* from, const char* from_end,
                           const int delim, I32* retlen)

=back

=back

=for hackers
Found in file util.c

=over 4

=item C<quadmath_format_needed>
X<quadmath_format_needed>

C<quadmath_format_needed()> returns true if the C<format> string seems to
contain at least one non-Q-prefixed C<%[efgaEFGA]> format specifier,
or returns false otherwise.

The format specifier detection is not complete printf-syntax detection,
but it should catch most common cases.

If true is returned, those arguments B<should> in theory be processed
with C<quadmath_snprintf()>, but in case there is more than one such
format specifier (see L</quadmath_format_valid>), and if there is
anything else beyond that one (even just a single byte), they
B<cannot> be processed because C<quadmath_snprintf()> is very strict,
accepting only one format spec, and nothing else.
In this case, the code should probably fail.

=over 3

 bool  quadmath_format_needed(const char* format)

=back

=back

=for hackers
Found in file util.c

=over 4

=item C<quadmath_format_valid>
X<quadmath_format_valid>

C<quadmath_snprintf()> is very strict about its C<format> string and will
fail, returning -1, if the format is invalid.  It accepts exactly
one format spec.

C<quadmath_format_valid()> checks that the intended single spec looks
sane: begins with C<%>, has only one C<%>, ends with C<[efgaEFGA]>,
and has C<Q> before it.  This is not a full "printf syntax check",
just the basics.

Returns true if it is valid, false if not.

See also L</quadmath_format_needed>.

=over 3

 bool  quadmath_format_valid(const char* format)

=back

=back

=for hackers
Found in file util.c

=head1 SV Flags

=over 4

=item C<SVt_INVLIST>
X<SVt_INVLIST>

Type flag for scalars.  See L<perlapi/svtype>.

=back

=for hackers
Found in file sv.h

=head1 SV Handling

=over 4

=item C<PL_Sv>
X<PL_Sv>

A scratch pad SV for whatever temporary use you need.  Chiefly used as a
fallback by macros on platforms where L<perlapi/PERL_USE_GCC_BRACE_GROUPS>> is
unavailable, and which would otherwise evaluate their SV parameter more than
once.

=over 3

   PL_Sv

=back

=back

=for hackers
Found in file intrpvar.h

=over 4

=item C<sv_2bool>
X<sv_2bool>

This macro is only used by C<sv_true()> or its macro equivalent, and only if
the latter's argument is neither C<SvPOK>, C<SvIOK> nor C<SvNOK>.
It calls C<sv_2bool_flags> with the C<SV_GMAGIC> flag.

=over 3

 bool  sv_2bool(SV *const sv)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_2bool_flags>
X<sv_2bool_flags>

This function is only used by C<sv_true()> and friends,  and only if
the latter's argument is neither C<SvPOK>, C<SvIOK> nor C<SvNOK>.  If the flags
contain C<SV_GMAGIC>, then it does an C<mg_get()> first.

=over 3

 bool  sv_2bool_flags(SV *sv, I32 flags)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_2num>
X<sv_2num>

NOTE: C<sv_2num> is B<experimental> and may change or be
removed without notice.

Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  The caller is expected to have handled
get-magic already.

=over 3

 SV*  sv_2num(SV *const sv)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_2pvbyte_nolen>
X<sv_2pvbyte_nolen>

Return a pointer to the byte-encoded representation of the SV.
May cause the SV to be downgraded from UTF-8 as a side-effect.

Usually accessed via the C<SvPVbyte_nolen> macro.

=over 3

 char*  sv_2pvbyte_nolen(SV* sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_2pvutf8_nolen>
X<sv_2pvutf8_nolen>

Return a pointer to the UTF-8-encoded representation of the SV.
May cause the SV to be upgraded to UTF-8 as a side-effect.

Usually accessed via the C<SvPVutf8_nolen> macro.

=over 3

 char*  sv_2pvutf8_nolen(SV* sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_2pv_flags>
X<sv_2pv_flags>

Returns a pointer to the string value of an SV, and sets C<*lp> to its length.
If flags has the C<SV_GMAGIC> bit set, does an C<mg_get()> first.  Coerces C<sv> to a
string if necessary.  Normally invoked via the C<SvPV_flags> macro.
C<sv_2pv()> and C<sv_2pv_nomg> usually end up here too.

=over 3

 char*  sv_2pv_flags(SV *const sv, STRLEN *const lp,
                     const U32 flags)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_2pv_nolen>
X<sv_2pv_nolen>

Like C<sv_2pv()>, but doesn't return the length too.  You should usually
use the macro wrapper C<SvPV_nolen(sv)> instead.

=over 3

 char*  sv_2pv_nolen(SV* sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_add_arena>
X<sv_add_arena>

Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.

=over 3

 void  sv_add_arena(char *const ptr, const U32 size,
                    const U32 flags)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_clean_all>
X<sv_clean_all>

Decrement the refcnt of each remaining SV, possibly triggering a
cleanup.  This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.

=over 3

 I32  sv_clean_all()

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_clean_objs>
X<sv_clean_objs>

Attempt to destroy all objects not yet freed.

=over 3

 void  sv_clean_objs()

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_free_arenas>
X<sv_free_arenas>

Deallocate the memory used by all arenas.  Note that all the individual SV
heads and bodies within the arenas must already have been freed.

=over 3

 void  sv_free_arenas()

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_grow>
X<sv_grow>

Expands the character buffer in the SV.  If necessary, uses C<sv_unref> and
upgrades the SV to C<SVt_PV>.  Returns a pointer to the character buffer.
Use the C<SvGROW> wrapper instead.

=over 3

 char*  sv_grow(SV *const sv, STRLEN newlen)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_iv>
X<sv_iv>

C<B<DEPRECATED!>>  It is planned to remove C<sv_iv> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

A private implementation of the C<SvIVx> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=over 3

 IV  sv_iv(SV* sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_newref>
X<sv_newref>

Increment an SV's reference count.  Use the C<SvREFCNT_inc()> wrapper
instead.

=over 3

 SV*  sv_newref(SV *const sv)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_nv>
X<sv_nv>

C<B<DEPRECATED!>>  It is planned to remove C<sv_nv> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

A private implementation of the C<SvNVx> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=over 3

 NV  sv_nv(SV* sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_pv>
X<sv_pv>

Use the C<SvPV_nolen> macro instead

=over 3

 char*  sv_pv(SV *sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_pvbyte>
X<sv_pvbyte>

Use C<SvPVbyte_nolen> instead.

=over 3

 char*  sv_pvbyte(SV *sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_pvbyten>
X<sv_pvbyten>

C<B<DEPRECATED!>>  It is planned to remove C<sv_pvbyten> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

A private implementation of the C<SvPVbyte> macro for compilers
which can't cope with complex macro expressions.  Always use the macro
instead.

=over 3

 char*  sv_pvbyten(SV *sv, STRLEN *lp)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_pvbyten_force>
X<sv_pvbyten_force>

The backend for the C<SvPVbytex_force> macro.  Always use the macro
instead.  If the SV cannot be downgraded from UTF-8, this croaks.

=over 3

 char*  sv_pvbyten_force(SV *const sv, STRLEN *const lp)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_pvn>
X<sv_pvn>

C<B<DEPRECATED!>>  It is planned to remove C<sv_pvn> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

A private implementation of the C<SvPV> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=over 3

 char*  sv_pvn(SV *sv, STRLEN *lp)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_pvn_force>
X<sv_pvn_force>

Get a sensible string out of the SV somehow.
A private implementation of the C<SvPV_force> macro for compilers which
can't cope with complex macro expressions.  Always use the macro instead.

=over 3

 char*  sv_pvn_force(SV* sv, STRLEN* lp)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_pvutf8>
X<sv_pvutf8>

Use the C<SvPVutf8_nolen> macro instead

=over 3

 char*  sv_pvutf8(SV *sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_pvutf8n>
X<sv_pvutf8n>

C<B<DEPRECATED!>>  It is planned to remove C<sv_pvutf8n> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

A private implementation of the C<SvPVutf8> macro for compilers
which can't cope with complex macro expressions.  Always use the macro
instead.

=over 3

 char*  sv_pvutf8n(SV *sv, STRLEN *lp)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_pvutf8n_force>
X<sv_pvutf8n_force>

The backend for the C<SvPVutf8x_force> macro.  Always use the macro
instead.

=over 3

 char*  sv_pvutf8n_force(SV *const sv, STRLEN *const lp)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_taint>
X<sv_taint>

Taint an SV.  Use C<SvTAINTED_on> instead.

=over 3

 void  sv_taint(SV* sv)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<sv_tainted>
X<sv_tainted>

Test an SV for taintedness.  Use C<SvTAINTED> instead.

=over 3

 bool  sv_tainted(SV *const sv)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<SvTHINKFIRST>
X<SvTHINKFIRST>

A quick flag check to see whether an C<sv> should be passed to C<sv_force_normal>
to be "downgraded" before C<SvIVX> or C<SvPVX> can be modified directly.

For example, if your scalar is a reference and you want to modify the C<SvIVX>
slot, you can't just do C<SvROK_off>, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
C<sv_setsv>, C<sv_setiv> and C<sv_pvn_force>.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

C<SvTHINKFIRST> sometimes produces false positives.  In those cases
C<sv_force_normal> does nothing.

=over 3

 U32  SvTHINKFIRST(SV *sv)

=back

=back

=for hackers
Found in file sv.h

=over 4

=item C<sv_true>
X<sv_true>

Returns true if the SV has a true value by Perl's rules.
Use the C<SvTRUE> macro instead, which may call C<sv_true()> or may
instead use an in-line version.

=over 3

 I32  sv_true(SV *const sv)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_untaint>
X<sv_untaint>

Untaint an SV.  Use C<SvTAINTED_off> instead.

=over 3

 void  sv_untaint(SV *const sv)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<sv_uv>
X<sv_uv>

C<B<DEPRECATED!>>  It is planned to remove C<sv_uv> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

A private implementation of the C<SvUVx> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=over 3

 UV  sv_uv(SV* sv)

=back

=back

=for hackers
Found in file mathoms.c

=head1 Time

There are only public API items currently in Time

=head1 Typedef names

There are only public API items currently in Typedef names

=head1 Unicode Support

=over 4

=item C<bytes_from_utf8_loc>
X<bytes_from_utf8_loc>

NOTE: C<bytes_from_utf8_loc> is B<experimental> and may change or be
removed without notice.

Like C<L<perlapi/bytes_from_utf8>()>, but takes an extra parameter, a pointer
to where to store the location of the first character in C<"s"> that cannot be
converted to non-UTF8.

If that parameter is C<NULL>, this function behaves identically to
C<bytes_from_utf8>.

Otherwise if C<*is_utf8p> is 0 on input, the function behaves identically to
C<bytes_from_utf8>, except it also sets C<*first_non_downgradable> to C<NULL>.

Otherwise, the function returns a newly created C<NUL>-terminated string
containing the non-UTF8 equivalent of the convertible first portion of
C<"s">.  C<*lenp> is set to its length, not including the terminating C<NUL>.
If the entire input string was converted, C<*is_utf8p> is set to a FALSE value,
and C<*first_non_downgradable> is set to C<NULL>.

Otherwise, C<*first_non_downgradable> is set to point to the first byte of the
first character in the original string that wasn't converted.  C<*is_utf8p> is
unchanged.  Note that the new string may have length 0.

Another way to look at it is, if C<*first_non_downgradable> is non-C<NULL> and
C<*is_utf8p> is TRUE, this function starts at the beginning of C<"s"> and
converts as many characters in it as possible stopping at the first one it
finds that can't be converted to non-UTF-8.  C<*first_non_downgradable> is
set to point to that.  The function returns the portion that could be converted
in a newly created C<NUL>-terminated string, and C<*lenp> is set to its length,
not including the terminating C<NUL>.  If the very first character in the
original could not be converted, C<*lenp> will be 0, and the new string will
contain just a single C<NUL>.  If the entire input string was converted,
C<*is_utf8p> is set to FALSE and C<*first_non_downgradable> is set to C<NULL>.

Upon successful return, the number of variants in the converted portion of the
string can be computed by having saved the value of C<*lenp> before the call,
and subtracting the after-call value of C<*lenp> from it.

=over 3

 U8*  bytes_from_utf8_loc(const U8 *s, STRLEN *lenp,
                          bool *is_utf8p,
                          const U8 ** first_unconverted)

=back

=back

=for hackers
Found in file utf8.c

=over 4

=item C<find_uninit_var>
X<find_uninit_var>

NOTE: C<find_uninit_var> is B<experimental> and may change or be
removed without notice.

Find the name of the undefined variable (if any) that caused the operator
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if its value matches C<uninit_sv>.
So roughly speaking, if a unary operator (such as C<OP_COS>) generates a
warning, then following the direct child of the op may yield an
C<OP_PADSV> or C<OP_GV> that gives the name of the undefined variable.  On the
other hand, with C<OP_ADD> there are two branches to follow, so we only print
the variable name if we get an exact match.
C<desc_p> points to a string pointer holding the description of the op.
This may be updated if needed.

The name is returned as a mortal SV.

Assumes that C<PL_op> is the OP that originally triggered the error, and that
C<PL_comppad>/C<PL_curpad> points to the currently executing pad.

=over 3

 SV*  find_uninit_var(const OP *const obase,
                      const SV *const uninit_sv, bool match,
                      const char **desc_p)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<isSCRIPT_RUN>
X<isSCRIPT_RUN>

Returns a bool as to whether or not the sequence of bytes from C<s> up to but
not including C<send> form a "script run".  C<utf8_target> is TRUE iff the
sequence starting at C<s> is to be treated as UTF-8.  To be precise, except for
two degenerate cases given below, this function returns TRUE iff all code
points in it come from any combination of three "scripts" given by the Unicode
"Script Extensions" property: Common, Inherited, and possibly one other.
Additionally all decimal digits must come from the same consecutive sequence of
10.

For example, if all the characters in the sequence are Greek, or Common, or
Inherited, this function will return TRUE, provided any decimal digits in it
are from the same block of digits in Common.  (These are the ASCII digits
"0".."9" and additionally a block for full width forms of these, and several
others used in mathematical notation.)   For scripts (unlike Greek) that have
their own digits defined this will accept either digits from that set or from
one of the Common digit sets, but not a combination of the two.  Some scripts,
such as Arabic, have more than one set of digits.  All digits must come from
the same set for this function to return TRUE.

C<*ret_script>, if C<ret_script> is not NULL, will on return of TRUE
contain the script found, using the C<SCX_enum> typedef.  Its value will be
C<SCX_INVALID> if the function returns FALSE.

If the sequence is empty, TRUE is returned, but C<*ret_script> (if asked for)
will be C<SCX_INVALID>.

If the sequence contains a single code point which is unassigned to a character
in the version of Unicode being used, the function will return TRUE, and the
script will be C<SCX_Unknown>.  Any other combination of unassigned code points
in the input sequence will result in the function treating the input as not
being a script run.

The returned script will be C<SCX_Inherited> iff all the code points in it are
from the Inherited script.

Otherwise, the returned script will be C<SCX_Common> iff all the code points in
it are from the Inherited or Common scripts.

=over 3

 bool  isSCRIPT_RUN(const U8 *s, const U8 *send,
                    const bool utf8_target)

=back

=back

=for hackers
Found in file regexec.c

=over 4

=item C<is_utf8_non_invariant_string>
X<is_utf8_non_invariant_string>

Returns TRUE if L<perlapi/is_utf8_invariant_string> returns FALSE for the first
C<len> bytes of the string C<s>, but they are, nonetheless, legal Perl-extended
UTF-8; otherwise returns FALSE.

A TRUE return means that at least one code point represented by the sequence
either is a wide character not representable as a single byte, or the
representation differs depending on whether the sequence is encoded in UTF-8 or
not.

See also
C<L<perlapi/is_utf8_invariant_string>>,
C<L<perlapi/is_utf8_string>>

=over 3

 bool  is_utf8_non_invariant_string(const U8* const s, STRLEN len)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<report_uninit>
X<report_uninit>

Print appropriate "Use of uninitialized variable" warning.

=over 3

 void  report_uninit(const SV *uninit_sv)

=back

=back

=for hackers
Found in file sv.c

=over 4

=item C<utf8n_to_uvuni>
X<utf8n_to_uvuni>

C<B<DEPRECATED!>>  It is planned to remove C<utf8n_to_uvuni> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

Instead use L<perlapi/utf8_to_uvchr_buf>, or rarely, L<perlapi/utf8n_to_uvchr>.

This function was useful for code that wanted to handle both EBCDIC and
ASCII platforms with Unicode properties, but starting in Perl v5.20, the
distinctions between the platforms have mostly been made invisible to most
code, so this function is quite unlikely to be what you want.  If you do need
this precise functionality, use instead
C<L<NATIVE_TO_UNI(utf8_to_uvchr_buf(...))|perlapi/utf8_to_uvchr_buf>>
or C<L<NATIVE_TO_UNI(utf8n_to_uvchr(...))|perlapi/utf8n_to_uvchr>>.

=over 3

 UV  utf8n_to_uvuni(const U8 *s, STRLEN curlen, STRLEN *retlen,
                    U32 flags)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<utf8_to_uvuni>
X<utf8_to_uvuni>

C<B<DEPRECATED!>>  It is planned to remove C<utf8_to_uvuni> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

Returns the Unicode code point of the first character in the string C<s>
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

Some, but not all, UTF-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is one reason why this function is deprecated.  The other is that only in
extremely limited circumstances should the Unicode versus native code point be
of any interest to you.  See L</utf8_to_uvuni_buf> for alternatives.

If C<s> points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> doesn't point to
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L<perlapi/utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.

=over 3

 UV  utf8_to_uvuni(const U8 *s, STRLEN *retlen)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<utf8_to_uvuni_buf>
X<utf8_to_uvuni_buf>

C<B<DEPRECATED!>>  It is planned to remove C<utf8_to_uvuni_buf> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

Only in very rare circumstances should code need to be dealing in Unicode
(as opposed to native) code points.  In those few cases, use
C<L<NATIVE_TO_UNI(utf8_to_uvchr_buf(...))|perlapi/utf8_to_uvchr_buf>> instead.
If you are not absolutely sure this is one of those cases, then assume it isn't
and use plain C<utf8_to_uvchr_buf> instead.

Returns the Unicode (not-native) code point of the first character in the
string C<s> which
is assumed to be in UTF-8 encoding; C<send> points to 1 beyond the end of C<s>.
C<retlen> will be set to the length, in bytes, of that character.

If C<s> does not point to a well-formed UTF-8 character and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L<perlapi/utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is
returned.

=over 3

 UV  utf8_to_uvuni_buf(const U8 *s, const U8 *send, STRLEN *retlen)

=back

=back

=for hackers
Found in file utf8.c

=over 4

=item C<uvoffuni_to_utf8_flags>
X<uvoffuni_to_utf8_flags>

THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
Instead, B<Almost all code should use L<perlapi/uvchr_to_utf8> or
L<perlapi/uvchr_to_utf8_flags>>.

This function is like them, but the input is a strict Unicode
(as opposed to native) code point.  Only in very rare circumstances should code
not be using the native code point.

For details, see the description for L<perlapi/uvchr_to_utf8_flags>.

=over 3

 U8*  uvoffuni_to_utf8_flags(U8 *d, UV uv, const UV flags)

=back

=back

=for hackers
Found in file utf8.c

=over 4

=item C<uvuni_to_utf8_flags>
X<uvuni_to_utf8_flags>

C<B<DEPRECATED!>>  It is planned to remove C<uvuni_to_utf8_flags> from a
future release of Perl.  Do not use it for new code; remove it from
existing code.

Instead you almost certainly want to use L<perlapi/uvchr_to_utf8> or
L<perlapi/uvchr_to_utf8_flags>.

This function is a deprecated synonym for L</uvoffuni_to_utf8_flags>,
which itself, while not deprecated, should be used only in isolated
circumstances.  These functions were useful for code that wanted to handle
both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl
v5.20, the distinctions between the platforms have mostly been made invisible
to most code, so this function is quite unlikely to be what you want.

=over 3

 U8*  uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)

=back

=back

=for hackers
Found in file mathoms.c

=over 4

=item C<valid_utf8_to_uvchr>
X<valid_utf8_to_uvchr>

Like C<L<perlapi/utf8_to_uvchr_buf>>, but should only be called when it is
known that the next character in the input UTF-8 string C<s> is well-formed
(I<e.g.>, it passes C<L<perlapi/isUTF8_CHAR>>.  Surrogates, non-character code
points, and non-Unicode code points are allowed.

=over 3

 UV  valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<variant_under_utf8_count>
X<variant_under_utf8_count>

This function looks at the sequence of bytes between C<s> and C<e>, which are
assumed to be encoded in ASCII/Latin1, and returns how many of them would
change should the string be translated into UTF-8.  Due to the nature of UTF-8,
each of these would occupy two bytes instead of the single one in the input
string.  Thus, this function returns the precise number of bytes the string
would expand by when translated to UTF-8.

Unlike most of the other functions that have C<utf8> in their name, the input
to this function is NOT a UTF-8-encoded string.  The function name is slightly
I<odd> to emphasize this.

This function is internal to Perl because khw thinks that any XS code that
would want this is probably operating too close to the internals.  Presenting a
valid use case could change that.

See also
C<L<perlapi/is_utf8_invariant_string>>
and
C<L<perlapi/is_utf8_invariant_string_loc>>,

=over 3

 Size_t  variant_under_utf8_count(const U8* const s,
                                  const U8* const e)

=back

=back

=for hackers
Found in file inline.h

=head1 Utility Functions

There are only public API items currently in Utility Functions

=head1 Versioning

There are only public API items currently in Versioning

=head1 Warning and Dieing

=over 4

=item C<PL_dowarn>
X<PL_dowarn>

The C variable that roughly corresponds to Perl's C<$^W> warning variable.
However, C<$^W> is treated as a boolean, whereas C<PL_dowarn> is a
collection of flag bits.

On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.

=over 3

 U8  PL_dowarn

=back

=back

=for hackers
Found in file intrpvar.h

=head1 XS

There are only public API items currently in XS

=head1 Undocumented elements

The following functions are currently undocumented.  If you use
one of them, you may wish to consider creating and submitting
documentation for it.

X<abort_execution>X<add_cp_to_invlist>X<_add_range_to_invlist>
X<alloc_LOGOP>X<allocmy>X<amagic_cmp>X<amagic_cmp_desc>
X<amagic_cmp_locale>X<amagic_cmp_locale_desc>X<amagic_is_enabled>
X<amagic_i_ncmp>X<amagic_i_ncmp_desc>X<amagic_ncmp>X<amagic_ncmp_desc>
X<append_utf8_from_native_byte>X<apply>X<ASCII_TO_NEED>X<av_arylen_p>
X<av_extend_guts>X<av_iter_p>X<av_nonelem>X<av_reify>X<bind_match>
X<boot_core_mro>X<boot_core_PerlIO>X<boot_core_UNIVERSAL>
X<_byte_dump_string>X<cando>X<cast_i32>X<cast_iv>X<cast_ulong>X<cast_uv>
X<check_utf8_print>X<ck_anoncode>X<ck_backtick>X<ck_bitop>X<ck_cmp>
X<ck_concat>X<ck_defined>X<ck_delete>X<ck_each>X<ck_entersub_args_core>
X<ck_eof>X<ck_eval>X<ck_exec>X<ck_exists>X<ck_ftst>X<ck_fun>X<ck_glob>
X<ck_grep>X<ck_index>X<ck_isa>X<ck_join>X<ck_length>X<ck_lfun>
X<ck_listiob>X<ck_match>X<ck_method>X<ck_null>X<ck_open>X<ck_prototype>
X<ck_readline>X<ck_refassign>X<ck_repeat>X<ck_require>X<ck_return>
X<ck_rfun>X<ck_rvconst>X<ck_sassign>X<ck_select>X<ck_shift>
X<ck_smartmatch>X<ck_sort>X<ck_spair>X<ck_split>X<ck_stringify>X<ck_subr>
X<ck_substr>X<ck_svconst>X<ck_tell>X<ck_trunc>X<ck_trycatch>X<ckwarn>
X<ckwarn_d>X<closest_cop>X<cmpchain_extend>X<cmpchain_finish>
X<cmpchain_start>X<cmp_desc>X<cmp_locale_desc>X<cntrl_to_mnemonic>
X<coresub_op>X<create_eval_scope>X<croak_caller>X<croak_memory_wrap>
X<croak_no_mem>X<croak_popstack>X<csighandler>X<csighandler1>
X<csighandler3>X<current_re_engine>X<custom_op_get_field>
X<cv_ckproto_len_flags>X<cv_clone_into>X<cv_const_sv_or_av>
X<cvgv_from_hek>X<cvgv_set>X<cvstash_set>X<cv_undef_flags>X<cx_dump>
X<cx_dup>X<cxinc>X<cx_popblock>X<cx_popeval>X<cx_popformat>X<cx_popgiven>
X<cx_poploop>X<cx_popsub>X<cx_popsub_args>X<cx_popsub_common>X<cx_popwhen>
X<cx_pushblock>X<cx_pusheval>X<cx_pushformat>X<cx_pushgiven>
X<cx_pushloop_for>X<cx_pushloop_plain>X<cx_pushsub>X<cx_pushtry>
X<cx_pushwhen>X<cx_topblock>X<deb_stack_all>X<defelem_target>
X<delete_eval_scope>X<despatch_signals>X<die_unwind>X<do_aexec>
X<do_aexec5>X<do_eof>X<does_utf8_overflow>X<do_exec>X<do_exec3>X<dofile>
X<do_gvgv_dump>X<do_gv_dump>X<do_hv_dump>X<doing_taint>X<do_ipcctl>
X<do_ipcget>X<do_magic_dump>X<do_msgrcv>X<do_msgsnd>X<do_ncmp>X<do_open6>
X<do_open_raw>X<do_op_dump>X<do_pmop_dump>X<do_print>X<do_readline>
X<do_seek>X<do_semop>X<do_shmio>X<do_sv_dump>X<do_sysseek>X<do_tell>
X<do_trans>X<do_uniprop_match>X<do_vecget>X<do_vecset>X<do_vop>
X<drand48_init_r>X<drand48_r>X<dtrace_probe_call>X<dtrace_probe_load>
X<dtrace_probe_op>X<dtrace_probe_phase>X<dump_all_perl>X<dump_indent>
X<dump_packsubs_perl>X<dump_sub_perl>X<dump_sv_child>X<dump_vindent>
X<dup_warnings>X<emulate_cop_io>X<find_first_differing_byte_pos>
X<find_lexical_cv>X<find_runcv_where>X<find_script>X<foldEQ_latin1>
X<foldEQ_latin1_s2_folded>X<foldEQ_utf8_flags>
X<_force_out_malformed_utf8_message>X<form_alien_digit_msg>
X<form_cp_too_large_msg>X<free_tied_hv_pool>X<free_tmps>
X<get_and_check_backslash_N_name>X<get_db_sub>X<get_debug_opts>
X<get_deprecated_property_msg>X<getenv_len>X<get_hash_seed>
X<get_invlist_iter_addr>X<get_invlist_offset_addr>
X<get_invlist_previous_index_addr>X<get_no_modify>X<get_opargs>
X<get_prop_definition>X<get_prop_values>X<get_regclass_nonbitmap_data>
X<get_regex_charset_name>X<get_re_arg>X<get_re_gclass_nonbitmap_data>
X<gimme_V>X<grok_bin_oct_hex>X<grok_bslash_c>X<grok_bslash_o>
X<grok_bslash_x>X<gv_check>X<gv_fetchmeth_internal>X<gv_override>
X<gv_setref>X<gv_stashpvn_internal>X<hfree_next_entry>
X<hv_backreferences_p>X<hv_common>X<hv_common_key_len>X<hv_kill_backrefs>
X<hv_placeholders_p>X<hv_pushkv>X<hv_undef_flags>X<init_argv_symbols>
X<init_constants>X<init_dbargs>X<init_debugger>X<init_i18nl10n>
X<init_i18nl14n>X<init_named_cv>X<init_uniprops>X<_inverse_folds>X<invert>
X<invlist_array>X<invlist_clear>X<invlist_clone>X<invlist_contents>
X<_invlistEQ>X<invlist_extend>X<invlist_highest>X<invlist_is_iterating>
X<invlist_iterfinish>X<invlist_iterinit>X<invlist_iternext>
X<invlist_lowest>X<invlist_max>X<invlist_previous_index>X<invlist_set_len>
X<invlist_set_previous_index>X<invlist_trim>X<_invlist_array_init>
X<_invlist_contains_cp>X<_invlist_dump>X<_invlist_intersection>
X<_invlist_intersection_maybe_complement_2nd>X<_invlist_invert>
X<_invlist_len>X<_invlist_search>X<_invlist_subtract>X<_invlist_union>
X<_invlist_union_maybe_complement_2nd>X<invmap_dump>X<io_close>
X<isFF_OVERLONG>X<is_grapheme>X<is_invlist>X<is_utf8_char_helper>
X<is_utf8_common>X<is_utf8_overlong_given_start_byte_ok>
X<_is_cur_LC_category_utf8>X<_is_in_locale_category>X<_is_uni_FOO>
X<_is_uni_perl_idcont>X<_is_uni_perl_idstart>X<_is_utf8_FOO>
X<_is_utf8_perl_idcont>X<_is_utf8_perl_idstart>X<jmaybe>X<keyword>
X<keyword_plugin_standard>X<list>X<load_charnames>X<localize>
X<lossless_NV_to_IV>X<magic_cleararylen_p>X<magic_clearenv>
X<magic_clearisa>X<magic_clearpack>X<magic_clearsig>X<magic_clear_all_env>
X<magic_copycallchecker>X<magic_existspack>X<magic_freearylen_p>
X<magic_freecollxfrm>X<magic_freemglob>X<magic_freeovrld>X<magic_freeutf8>
X<magic_get>X<magic_getarylen>X<magic_getdebugvar>X<magic_getdefelem>
X<magic_getnkeys>X<magic_getpack>X<magic_getpos>X<magic_getsig>
X<magic_getsubstr>X<magic_gettaint>X<magic_getuvar>X<magic_getvec>
X<magic_killbackrefs>X<magic_nextpack>X<magic_regdata_cnt>
X<magic_regdatum_get>X<magic_regdatum_set>X<magic_scalarpack>X<magic_set>
X<magic_setarylen>X<magic_setcollxfrm>X<magic_setdbline>
X<magic_setdebugvar>X<magic_setdefelem>X<magic_setenv>X<magic_setisa>
X<magic_setlvref>X<magic_setmglob>X<magic_setnkeys>X<magic_setnonelem>
X<magic_setpack>X<magic_setpos>X<magic_setregexp>X<magic_setsig>
X<magic_setsubstr>X<magic_settaint>X<magic_setutf8>X<magic_setuvar>
X<magic_setvec>X<magic_set_all_env>X<magic_sizepack>X<magic_wipepack>
X<malloced_size>X<malloc_good_size>X<mem_collxfrm>X<mem_log_alloc>
X<mem_log_free>X<mem_log_realloc>X<_mem_collxfrm>X<mg_find_mglob>
X<mode_from_discipline>X<more_bodies>X<moreswitches>X<mortal_getenv>
X<mro_get_private_data>X<mro_meta_dup>X<mro_meta_init>
X<multiconcat_stringify>X<multideref_stringify>X<my_atof2>X<my_atof3>
X<my_attrs>X<my_clearenv>X<my_lstat>X<my_lstat_flags>X<my_memrchr>
X<my_mkostemp>X<my_mkostemp_cloexec>X<my_mkstemp>X<my_mkstemp_cloexec>
X<my_stat>X<my_stat_flags>X<my_strerror>X<my_unexec>X<NATIVE_TO_NEED>
X<newGP>X<newMETHOP_internal>X<newSTUB>X<newSVavdefelem>
X<new_warnings_bitfield>X<newXS_deffile>X<_new_invlist>
X<_new_invlist_C_array>X<nextargv>X<no_bareword_filehandle>X<noperl_die>
X<notify_parser_that_changed_to_utf8>X<oopsAV>X<oopsHV>X<op_clear>
X<op_integerize>X<op_lvalue_flags>X<opmethod_stash>X<op_refcnt_dec>
X<op_refcnt_inc>X<op_relocate_sv>X<opslab_force_free>X<opslab_free>
X<opslab_free_nopad>X<op_std_init>X<op_unscope>X<package>
X<package_version>X<pad_add_weakref>X<padlist_store>X<padname_free>
X<PadnameIN_SCOPE>X<padnamelist_free>X<parser_free>
X<parser_free_nexttoke_ops>X<parse_unicode_opts>X<path_is_searchable>
X<peep>X<PerlIO_restore_errno>X<PerlIO_save_errno>X<PerlLIO_dup2_cloexec>
X<PerlLIO_dup_cloexec>X<PerlLIO_open3_cloexec>X<PerlLIO_open_cloexec>
X<PerlProc_pipe_cloexec>X<PerlSock_accept_cloexec>
X<PerlSock_socketpair_cloexec>X<PerlSock_socket_cloexec>
X<perly_sighandler>X<pmruntime>X<POPMARK>X<populate_isa>X<pregfree2>
X<ptr_hash>X<qerror>X<ReANY>X<reentrant_free>X<reentrant_init>
X<reentrant_retry>X<reentrant_size>X<re_exec_indentf>X<ref>X<regcurly>
X<regdupe_internal>X<regexec_flags>X<regfree_internal>X<reginitcolors>
X<reg_named_buff>X<reg_named_buff_all>X<reg_named_buff_exists>
X<reg_named_buff_fetch>X<reg_named_buff_firstkey>X<reg_named_buff_iter>
X<reg_named_buff_nextkey>X<reg_named_buff_scalar>X<regnext>
X<reg_numbered_buff_fetch>X<reg_numbered_buff_length>
X<reg_numbered_buff_store>X<regprop>X<reg_qr_package>X<reg_skipcomment>
X<reg_temp_copy>X<re_indentf>X<re_intuit_start>X<re_intuit_string>
X<re_op_compile>X<report_evil_fh>X<report_redefined_cv>
X<report_wrongway_fh>X<re_printf>X<rpeep>X<rsignal_restore>X<rsignal_save>
X<runops_debug>X<runops_standard>X<rxres_save>X<same_dirent>X<save_bool>
X<save_clearsv>X<save_delete>X<save_destructor>X<save_destructor_x>
X<save_freeop>X<save_freepv>X<save_freesv>X<save_I16>X<save_I32>X<save_I8>
X<save_int>X<save_iv>X<save_long>X<save_mortalizesv>X<save_pptr>
X<save_re_context>X<save_sptr>X<save_strlen>X<save_to_buffer>X<sawparens>
X<scalar>X<scalarvoid>X<scan_num>X<scan_str>X<scan_word>X<set_caret_X>
X<setfd_cloexec>X<setfd_cloexec_for_nonsysfd>
X<setfd_cloexec_or_inhexec_by_sysfdness>X<setfd_inhexec>
X<setfd_inhexec_for_sysfd>X<set_numeric_standard>X<set_numeric_underlying>
X<set_padlist>X<_setup_canned_invlist>X<should_warn_nl>
X<should_we_output_Debug_r>X<sighandler>X<sighandler1>X<sighandler3>
X<skipspace_flags>X<Slab_Alloc>X<Slab_Free>X<Slab_to_ro>X<Slab_to_rw>
X<softref2xv>X<sortsv_flags_impl>X<stack_grow>X<str_to_version>
X<sub_crush_depth>X<sv_2iv>X<sv_2pv>X<sv_2uv>X<sv_add_backref>
X<sv_buf_to_ro>X<sv_del_backref>X<sv_free2>X<sv_i_ncmp>X<sv_i_ncmp_desc>
X<sv_kill_backrefs>X<sv_len_utf8_nomg>X<sv_magicext_mglob>X<sv_ncmp>
X<sv_ncmp_desc>X<sv_only_taint_gmagic>X<sv_or_pv_pos_u2b>X<sv_resetpvn>
X<sv_sethek>X<sv_setsv_cow>X<SvTRUE_common>X<sv_unglob>X<sys_init>
X<sys_init3>X<sys_term>X<tied_method>X<tmps_grow_p>X<TOPMARK>
X<to_uni_fold>X<to_uni_lower>X<to_uni_title>X<to_uni_upper>
X<_to_fold_latin1>X<_to_uni_fold_flags>X<_to_upper_title_latin1>
X<_to_utf8_fold_flags>X<_to_utf8_lower_flags>X<_to_utf8_title_flags>
X<_to_utf8_upper_flags>X<translate_substr_offsets>X<try_amagic_bin>
X<try_amagic_un>X<uiv_2buf>X<unlnk>X<unshare_hek>X<utf16_to_utf8>
X<utf16_to_utf8_reversed>X<_utf8n_to_uvchr_msgs_helper>
X<utf8_to_uvchr_buf_helper>X<utilize>X<uvoffuni_to_utf8_flags_msgs>
X<uvuni_to_utf8>X<valid_utf8_to_uvuni>X<variant_byte_number>X<varname>
X<vivify_defelem>X<vivify_ref>X<wait4pid>X<_warn_problematic_locale>
X<was_lvalue_sub>X<watch>X<win32_croak_not_implemented>X<write_to_stderr>
X<xs_boot_epilog>X<xs_handshake>X<yyerror>X<yyerror_pv>X<yyerror_pvn>
X<yylex>X<yyparse>X<yyquit>X<yyunlex>


=over 4

 abort_execution
 add_cp_to_invlist
 _add_range_to_invlist
 alloc_LOGOP
 allocmy
 amagic_cmp
 amagic_cmp_desc
 amagic_cmp_locale
 amagic_cmp_locale_desc
 amagic_is_enabled
 amagic_i_ncmp
 amagic_i_ncmp_desc
 amagic_ncmp
 amagic_ncmp_desc
 append_utf8_from_native_byte
 apply
 ASCII_TO_NEED
 av_arylen_p
 av_extend_guts
 av_iter_p
 av_nonelem
 av_reify
 bind_match
 boot_core_mro
 boot_core_PerlIO
 boot_core_UNIVERSAL
 _byte_dump_string
 cando
 cast_i32
 cast_iv
 cast_ulong
 cast_uv
 check_utf8_print
 ck_anoncode
 ck_backtick
 ck_bitop
 ck_cmp
 ck_concat
 ck_defined
 ck_delete
 ck_each
 ck_entersub_args_core
 ck_eof
 ck_eval
 ck_exec
 ck_exists
 ck_ftst
 ck_fun
 ck_glob
 ck_grep
 ck_index
 ck_isa
 ck_join
 ck_length
 ck_lfun
 ck_listiob
 ck_match
 ck_method
 ck_null
 ck_open
 ck_prototype
 ck_readline
 ck_refassign
 ck_repeat
 ck_require
 ck_return
 ck_rfun
 ck_rvconst
 ck_sassign
 ck_select
 ck_shift
 ck_smartmatch
 ck_sort
 ck_spair
 ck_split
 ck_stringify
 ck_subr
 ck_substr
 ck_svconst
 ck_tell
 ck_trunc
 ck_trycatch
 ckwarn
 ckwarn_d
 closest_cop
 cmpchain_extend
 cmpchain_finish
 cmpchain_start
 cmp_desc
 cmp_locale_desc
 cntrl_to_mnemonic
 coresub_op
 create_eval_scope
 croak_caller
 croak_memory_wrap
 croak_no_mem
 croak_popstack
 csighandler
 csighandler1
 csighandler3
 current_re_engine
 custom_op_get_field
 cv_ckproto_len_flags
 cv_clone_into
 cv_const_sv_or_av
 cvgv_from_hek
 cvgv_set
 cvstash_set
 cv_undef_flags
 cx_dump
 cx_dup
 cxinc
 cx_popblock
 cx_popeval
 cx_popformat
 cx_popgiven
 cx_poploop
 cx_popsub
 cx_popsub_args
 cx_popsub_common
 cx_popwhen
 cx_pushblock
 cx_pusheval
 cx_pushformat
 cx_pushgiven
 cx_pushloop_for
 cx_pushloop_plain
 cx_pushsub
 cx_pushtry
 cx_pushwhen
 cx_topblock
 deb_stack_all
 defelem_target
 delete_eval_scope
 despatch_signals
 die_unwind
 do_aexec
 do_aexec5
 do_eof
 does_utf8_overflow
 do_exec
 do_exec3
 dofile
 do_gvgv_dump
 do_gv_dump
 do_hv_dump
 doing_taint
 do_ipcctl
 do_ipcget
 do_magic_dump
 do_msgrcv
 do_msgsnd
 do_ncmp
 do_open6
 do_open_raw
 do_op_dump
 do_pmop_dump
 do_print
 do_readline
 do_seek
 do_semop
 do_shmio
 do_sv_dump
 do_sysseek
 do_tell
 do_trans
 do_uniprop_match
 do_vecget
 do_vecset
 do_vop
 drand48_init_r
 drand48_r
 dtrace_probe_call
 dtrace_probe_load
 dtrace_probe_op
 dtrace_probe_phase
 dump_all_perl
 dump_indent
 dump_packsubs_perl
 dump_sub_perl
 dump_sv_child
 dump_vindent
 dup_warnings
 emulate_cop_io
 find_first_differing_byte_pos
 find_lexical_cv
 find_runcv_where
 find_script
 foldEQ_latin1
 foldEQ_latin1_s2_folded
 foldEQ_utf8_flags
 _force_out_malformed_utf8_message
 form_alien_digit_msg
 form_cp_too_large_msg
 free_tied_hv_pool
 free_tmps
 get_and_check_backslash_N_name
 get_db_sub
 get_debug_opts
 get_deprecated_property_msg
 getenv_len
 get_hash_seed
 get_invlist_iter_addr
 get_invlist_offset_addr
 get_invlist_previous_index_addr
 get_no_modify
 get_opargs
 get_prop_definition
 get_prop_values
 get_regclass_nonbitmap_data
 get_regex_charset_name
 get_re_arg
 get_re_gclass_nonbitmap_data
 gimme_V
 grok_bin_oct_hex
 grok_bslash_c
 grok_bslash_o
 grok_bslash_x
 gv_check
 gv_fetchmeth_internal
 gv_override
 gv_setref
 gv_stashpvn_internal
 hfree_next_entry
 hv_backreferences_p
 hv_common
 hv_common_key_len
 hv_kill_backrefs
 hv_placeholders_p
 hv_pushkv
 hv_undef_flags
 init_argv_symbols
 init_constants
 init_dbargs
 init_debugger
 init_i18nl10n
 init_i18nl14n
 init_named_cv
 init_uniprops
 _inverse_folds
 invert
 invlist_array
 invlist_clear
 invlist_clone
 invlist_contents
 _invlistEQ
 invlist_extend
 invlist_highest
 invlist_is_iterating
 invlist_iterfinish
 invlist_iterinit
 invlist_iternext
 invlist_lowest
 invlist_max
 invlist_previous_index
 invlist_set_len
 invlist_set_previous_index
 invlist_trim
 _invlist_array_init
 _invlist_contains_cp
 _invlist_dump
 _invlist_intersection
 _invlist_intersection_maybe_complement_2nd
 _invlist_invert
 _invlist_len
 _invlist_search
 _invlist_subtract
 _invlist_union
 _invlist_union_maybe_complement_2nd
 invmap_dump
 io_close
 isFF_OVERLONG
 is_grapheme
 is_invlist
 is_utf8_char_helper
 is_utf8_common
 is_utf8_overlong_given_start_byte_ok
 _is_cur_LC_category_utf8
 _is_in_locale_category
 _is_uni_FOO
 _is_uni_perl_idcont
 _is_uni_perl_idstart
 _is_utf8_FOO
 _is_utf8_perl_idcont
 _is_utf8_perl_idstart
 jmaybe
 keyword
 keyword_plugin_standard
 list
 load_charnames
 localize
 lossless_NV_to_IV
 magic_cleararylen_p
 magic_clearenv
 magic_clearisa
 magic_clearpack
 magic_clearsig
 magic_clear_all_env
 magic_copycallchecker
 magic_existspack

=back


=head1 AUTHORS

The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl.  Documentation is by whoever was kind enough to
document their functions.

=head1 SEE ALSO

F<config.h>, L<perlapi>, L<perlapio>, L<perlcall>, L<perlclib>, L<perlfilter>, L<perlguts>, L<perlinterp>, L<perliol>, L<perlmroapi>, L<perlreguts>, L<perlxs>

=cut

ex: set ro:
