.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Accessor::Classy 3"
.TH Class::Accessor::Classy 3 "2022-04-26" "perl v5.34.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Accessor::Classy \- accessors with minimal inheritance
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package YourPackage;
\&
\&  use Class::Accessor::Classy;
\&    with qw(new);              # with a new() method
\&    ro qw(foo);                # read\-only
\&    rw qw(bar);                # read\-write
\&    rs baz => \e (my $set_baz); # read\-only, plus a secret writer
\&
\&    # alternatively:
\&    my $set_bip = rs \*(Aqbip\*(Aq;
\&
\&    ro_c suitcase => \*(Aqred\*(Aq;    # read\-only class data
\&    rw_c hat      => \*(Aqblack\*(Aq;  # read\-write class data
\&    rs_c socks    => \e (my $set_socks) => undef;
\&
\&    # alternative secret writer syntax
\&    my $set_shoes = rs_c shoes => undef;
\&
\&    # also class read\-only:
\&    constant seven => 7;
\&    constant eight => this\->seven + 1;
\&  no  Class::Accessor::Classy;
\&  # ^\-\- removes all of the syntax bits from your namespace
\&
\&  package whatever;
\&
\&  YourPackage\->set_hat(undef);
\&  my $obj = YourPackage\->new(foo => 4, bar => 2);
\&  # NOTE I\*(Aqm thinking of deprecating the get_foo() usage
\&  warn "foo ", $obj\->foo;
\&  YourPackage\->$set_socks("tube");
.Ve
.SH "About"
.IX Header "About"
This module provides an extremely small-footprint accessor/mutator
declaration scheme for fast and convenient object attribute setup.  It
is intended as a simple and speedy mechanism for preventing hash-key
typos rather than a full-blown object system with type checking and so
on.
.PP
The accessor methods appear as a hidden parent class of your package and
generally try to stay out of the way.  The accessors and mutators
generated are of the form \f(CW\*(C`foo()\*(C'\fR and \f(CW\*(C`set_foo()\*(C'\fR, respectively.
.SH "Frontend"
.IX Header "Frontend"
Unlike other class-modifying code, this is not designed to be inherited
from.  Instead, you simply use it and get an invisible subclass
containing your accessors.  If you use the 'no' syntax (to call
unimport), you are left with a squeaky-clean namespace.
.PP
After 'use' and before 'no', the following pieces of syntax are
available.
.SS "with"
.IX Subsection "with"
Add a 'standard' method to your class.
.IP "new" 4
.IX Item "new"
.SS "ro"
.IX Subsection "ro"
Read-only properties (accessors only.)
.PP
.Vb 1
\&  ro qw(foo bar baz);
.Ve
.SS "rw"
.IX Subsection "rw"
Define read-write (accessor + mutator) properties.
.PP
.Vb 1
\&  rw qw(foo bar baz);
.Ve
.SS "lv"
.IX Subsection "lv"
Properties with lvalue accessors.
.PP
.Vb 1
\&  lv qw(thing deal stuff);
.Ve
.SS "ri"
.IX Subsection "ri"
Immutable properties.  Once set, further calls to the mutator throw
errors.
.PP
.Vb 1
\&  ri qw(foo bar baz);
.Ve
.SS "rs"
.IX Subsection "rs"
Read-only properties with a secret mutator.
.PP
.Vb 1
\&  rs foo => \e(my $set_foo);
.Ve
.SS "lo"
.IX Subsection "lo"
Read-only list properties.  These are stored as an array-ref, but the
accessor returns a list.
.PP
.Vb 1
\&  lo qw(foo bar baz);
.Ve
.SS "lw"
.IX Subsection "lw"
Read-write list properties.  The mutator takes a list.
.PP
.Vb 1
\&  lw \*(Aqfoo\*(Aq;
.Ve
.PP
This defaults to create \fBfoo()\fR|\fBget_foo()\fR, \fBset_foo()\fR, and \fBadd_foo()\fR
methods.  Other features are possible here, but currently experimental.
.SS "ls"
.IX Subsection "ls"
List property with a secret mutator.
.PP
.Vb 1
\&  ls foo => \e(my $set_foo);
.Ve
.SS "this"
.IX Subsection "this"
A shortcut for your classname.  Useful for e.g. defining one constant in
terms of another.
.PP
.Vb 1
\&  this\->some_class_method;
.Ve
.SS "getter"
.IX Subsection "getter"
Define a custom getter.
.SS "setter"
.IX Subsection "setter"
Define a custom setter.
.SS "constant"
.IX Subsection "constant"
A class constant.
.PP
.Vb 1
\&  constant foo => 7;
.Ve
.SS "ro_c"
.IX Subsection "ro_c"
Read-only class method.
.SS "rw_c"
.IX Subsection "rw_c"
A read-write class method, with a default.
.PP
.Vb 1
\&  rw_c foo => 9;
.Ve
.SS "rs_c"
.IX Subsection "rs_c"
A class method with a secret setter.
.PP
.Vb 1
\&  rs_c bar => \e(my $set_bar) => 12;
.Ve
.SS "in"
.IX Subsection "in"
Specify the destination package.  You need to set this before defining
anything else (but it is usually best to just not set it.)
.PP
.Vb 1
\&  in \*(Aqwhy_be_so_secretive\*(Aq;
.Ve
.SS "aka"
.IX Subsection "aka"
Add an alias for an existing method.
.PP
.Vb 1
\&  aka have_method => \*(Aqwant_method\*(Aq, \*(Aqand_also_want\*(Aq;
.Ve
.SH "Utilities"
.IX Header "Utilities"
This introspection stuff is unreliable \*(-- don't use it.
.SS "find_accessors"
.IX Subsection "find_accessors"
.Vb 1
\&  @attribs = Class::Accessor::Classy\->find_accessors($class);
.Ve
.SS "find_subclasses"
.IX Subsection "find_subclasses"
.Vb 1
\&  @classlist = Class::Accessor::Classy\->find_subclasses($class);
.Ve
.SH "Subclassable"
.IX Header "Subclassable"
Customized subclasses may override these methods to create a new kind of
accessor generator.
.IP "\s-1NOTE\s0" 4
.IX Item "NOTE"
You do not subclass Class::Accessor::Classy to construct your objects.
.Sp
If you are just creating MyObject, you are not inheriting any of these
methods.
.Sp
The rest of this documentation only pertains to you if you are trying to
create something like Class::Accessor::Classy::MyWay.
.IP "notation:" 4
.IX Item "notation:"
Read these as: \f(CW$CAC\fR = 'Class::Accessor::Classy'; (or whatever subclass
you're creating.)
.SS "exports"
.IX Subsection "exports"
.Vb 1
\&  my %exports = $CAC\->exports;
.Ve
.SS "import"
.IX Subsection "import"
.Vb 1
\&  $CAC\->import;
.Ve
.SS "unimport"
.IX Subsection "unimport"
.Vb 1
\&  $CAC\->unimport;
.Ve
.SS "create_package"
.IX Subsection "create_package"
Creates and returns the package in which the accessors will live.  Also
pushes the created accessor package into the caller's \f(CW@ISA\fR.
.PP
If it already exists, simply returns the cached value.
.PP
.Vb 4
\&  my $package = $CAC\->create_package(
\&    class => $caller,
\&    in    => $package, # optional
\&  );
.Ve
.SS "install_sub"
.IX Subsection "install_sub"
.Vb 1
\&  $CAC\->install_sub($class, $name, $subref, $note);
.Ve
.SS "annotate"
.IX Subsection "annotate"
.Vb 1
\&  $CAC\->annotate($class, $name, $note);
.Ve
.SS "get_notes"
.IX Subsection "get_notes"
.Vb 1
\&  my %notes = $CAC\->get_notes;
.Ve
.SS "make_standards"
.IX Subsection "make_standards"
.Vb 1
\&  $CAC\->make_standards($class, @list);
.Ve
.SS "_getter"
.IX Subsection "_getter"
Returns a compiled getter subref corresponding to whether or not the
class has a '\-\-get' method.
.PP
.Vb 1
\&  $CAC\->_getter($class, $item);
.Ve
.SS "make_getters"
.IX Subsection "make_getters"
.Vb 1
\&  $CAC\->make_getters($class, @list);
.Ve
.SS "make_lv_getters"
.IX Subsection "make_lv_getters"
.Vb 1
\&  $CAC\->make_lv_getters($class, @list);
.Ve
.SS "_setter"
.IX Subsection "_setter"
Returns a compiled setter subref corresponding to whether or not the
class has a '\-\-set' method.
.PP
.Vb 1
\&  $CAC\->_setter($class, $item);
.Ve
.SS "make_setters"
.IX Subsection "make_setters"
.Vb 1
\&  $CAC\->make_setters($class, @list);
.Ve
.SS "make_immutable"
.IX Subsection "make_immutable"
Creates immutable (one-time-only) setters.
.PP
.Vb 1
\&  CAC\->make_immutable($class, @list);
.Ve
.SS "make_secrets"
.IX Subsection "make_secrets"
.Vb 1
\&  my @names = $CAC\->make_secrets($class, @list);
.Ve
.SS "make_aliases"
.IX Subsection "make_aliases"
Constructs 'get_' aliases for a \f(CW@list\fR of accessors.
.PP
.Vb 1
\&  $CAC\->make_aliases($class, @list);
.Ve
.SS "make_aka"
.IX Subsection "make_aka"
Create a list of alias methods which runtime refer to \f(CW$realname\fR.
.PP
.Vb 1
\&  $CAC\->make_aka($where, $realname, @aliases);
.Ve
.SS "do_eval"
.IX Subsection "do_eval"
.Vb 1
\&  my $subref = $package\->do_eval($string, @checks);
.Ve
.SH "List Accessors"
.IX Header "List Accessors"
.SS "make_array_method"
.IX Subsection "make_array_method"
.Vb 6
\&  $CAC\->make_array_method(
\&    class     => $class,
\&    item      => $name,
\&    functions => [@functions],
\&    secret    => $bool,
\&  );
.Ve
.PP
If secret is true, will return the list of names.
.SS "_get_array_subs"
.IX Subsection "_get_array_subs"
.Vb 1
\&  my %subs = $CAC\->_get_array_subs($name);
.Ve
.SH "Class Accessors"
.IX Header "Class Accessors"
.SS "make_class_data"
.IX Subsection "make_class_data"
.Vb 1
\&  $CAC\->make_class_data($mode, $class, $key, $value);
.Ve
.PP
If mode is 'rs', returns the secret setter name.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eric Wilhelm @ <ewilhelm at cpan dot org>
.PP
http://scratchcomputing.com/
.SH "BUGS"
.IX Header "BUGS"
If you found this module on \s-1CPAN,\s0 please report any bugs or feature
requests through the web interface at <http://rt.cpan.org>.  I will be
notified, and then you'll automatically be notified of progress on your
bug as I make changes.
.PP
If you pulled this development version from my /svn/, please contact me
directly.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006\-2007 Eric L. Wilhelm, All Rights Reserved.
.SH "NO WARRANTY"
.IX Header "NO WARRANTY"
Absolutely, positively \s-1NO WARRANTY,\s0 neither express or implied, is
offered with this software.  You use this software at your own risk.  In
case of loss, no person or entity owes you anything whatseover.  You
have been warned.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
