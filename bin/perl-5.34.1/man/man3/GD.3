.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "GD 3"
.TH GD 3 "2022-02-01" "perl v5.34.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GD.pm \- Interface to Gd Graphics Library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use GD;
\&
\&    # create a new image
\&    $im = GD::Image\->new(100,100);
\&
\&    # allocate some colors
\&    $white = $im\->colorAllocate(255,255,255);
\&    $black = $im\->colorAllocate(0,0,0);       
\&    $red = $im\->colorAllocate(255,0,0);      
\&    $blue = $im\->colorAllocate(0,0,255);
\&
\&    # make the background transparent and interlaced
\&    $im\->transparent($white);
\&    $im\->interlaced(\*(Aqtrue\*(Aq);
\&
\&    # Put a black frame around the picture
\&    $im\->rectangle(0,0,99,99,$black);
\&
\&    # Draw a blue oval
\&    $im\->arc(50,50,95,75,0,360,$blue);
\&
\&    # And fill it with red
\&    $im\->fill(50,50,$red);
\&
\&    # make sure we are writing to a binary stream
\&    binmode STDOUT;
\&
\&    # Convert the image to PNG and print it on standard output
\&    print $im\->png;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1GD\s0.pm\fR is a Perl interface to Thomas Boutell's gd graphics library
(version 2.01 or higher; see below). \s-1GD\s0 allows you to create color
drawings using a large number of graphics primitives, and emit the
drawings as \s-1PNG\s0 files.
.PP
\&\s-1GD\s0 defines the following four classes:
.ie n .IP """GD::Image""" 5
.el .IP "\f(CWGD::Image\fR" 5
.IX Item "GD::Image"
An image class, which holds the image data and accepts graphic
primitive method calls.
.ie n .IP """GD::Font""" 5
.el .IP "\f(CWGD::Font\fR" 5
.IX Item "GD::Font"
A font class, which holds static font information and used for text
rendering.
.ie n .IP """GD::Polygon""" 5
.el .IP "\f(CWGD::Polygon\fR" 5
.IX Item "GD::Polygon"
A simple polygon object, used for storing lists of vertices prior to
rendering a polygon into an image.
.ie n .IP """GD::Simple""" 5
.el .IP "\f(CWGD::Simple\fR" 5
.IX Item "GD::Simple"
A \*(L"simple\*(R" class that simplifies the GD::Image \s-1API\s0 and then adds a set
of object-oriented drawing methods using turtle graphics, simplified
font handling, ability to work in polar coordinates, \s-1HSV\s0 color spaces,
and human-readable color names like \*(L"lightblue\*(R". Please see
GD::Simple for a description of these methods.
.PP
A Simple Example:
.PP
.Vb 1
\&        #!/usr/bin/perl
\&
\&        use GD;
\&
\&        # create a new image
\&        $im = GD::Image\->new(100,100);
\&
\&        # allocate some colors
\&        $white = $im\->colorAllocate(255,255,255);
\&        $black = $im\->colorAllocate(0,0,0);       
\&        $red = $im\->colorAllocate(255,0,0);      
\&        $blue = $im\->colorAllocate(0,0,255);
\&
\&        # make the background transparent and interlaced
\&        $im\->transparent($white);
\&        $im\->interlaced(\*(Aqtrue\*(Aq);
\&
\&        # Put a black frame around the picture
\&        $im\->rectangle(0,0,99,99,$black);
\&
\&        # Draw a blue oval
\&        $im\->arc(50,50,95,75,0,360,$blue);
\&
\&        # And fill it with red
\&        $im\->fill(50,50,$red);
\&
\&        # make sure we are writing to a binary stream
\&        binmode STDOUT;
\&
\&        # Convert the image to PNG and print it on standard output
\&        print $im\->png;
.Ve
.PP
Notes:
.IP "1. To create a new, empty image, send a \fBnew()\fR message to GD::Image, passing it the width and height of the image you want to create.  An image object will be returned.  Other class methods allow you to initialize an image from a preexisting \s-1JPG, PNG, GD, GD2, XBM\s0 or other supported image files." 5
.IX Item "1. To create a new, empty image, send a new() message to GD::Image, passing it the width and height of the image you want to create. An image object will be returned. Other class methods allow you to initialize an image from a preexisting JPG, PNG, GD, GD2, XBM or other supported image files."
.PD 0
.IP "2. Next you will ordinarily add colors to the image's color table. colors are added using a \fBcolorAllocate()\fR method call.  The three parameters in each call are the red, green and blue (rgb) triples for the desired color.  The method returns the index of that color in the image's color table.  You should store these indexes for later use." 5
.IX Item "2. Next you will ordinarily add colors to the image's color table. colors are added using a colorAllocate() method call. The three parameters in each call are the red, green and blue (rgb) triples for the desired color. The method returns the index of that color in the image's color table. You should store these indexes for later use."
.IP "3. Now you can do some drawing!  The various graphics primitives are described below.  In this example, we do some text drawing, create an oval, and create and draw a polygon." 5
.IX Item "3. Now you can do some drawing! The various graphics primitives are described below. In this example, we do some text drawing, create an oval, and create and draw a polygon."
.IP "4. Polygons are created with a \fBnew()\fR message to GD::Polygon.  You can add points to the returned polygon one at a time using the \fBaddPt()\fR method. The polygon can then be passed to an image for rendering." 5
.IX Item "4. Polygons are created with a new() message to GD::Polygon. You can add points to the returned polygon one at a time using the addPt() method. The polygon can then be passed to an image for rendering."
.ie n .IP "5. When you're done drawing, you can convert the image into \s-1PNG\s0 format by sending it a \fBpng()\fR message (or any other supported image format).  It will return a (potentially large) scalar value containing the binary data for the image.  Ordinarily you will print it out at this point or write it to a file.  To ensure portability to platforms that differentiate between text and binary files, be sure to call ""binmode()"" on the file you are writing the image to." 5
.el .IP "5. When you're done drawing, you can convert the image into \s-1PNG\s0 format by sending it a \fBpng()\fR message (or any other supported image format).  It will return a (potentially large) scalar value containing the binary data for the image.  Ordinarily you will print it out at this point or write it to a file.  To ensure portability to platforms that differentiate between text and binary files, be sure to call \f(CWbinmode()\fR on the file you are writing the image to." 5
.IX Item "5. When you're done drawing, you can convert the image into PNG format by sending it a png() message (or any other supported image format). It will return a (potentially large) scalar value containing the binary data for the image. Ordinarily you will print it out at this point or write it to a file. To ensure portability to platforms that differentiate between text and binary files, be sure to call binmode() on the file you are writing the image to."
.PD
.SH "Object Constructors: Creating Images"
.IX Header "Object Constructors: Creating Images"
See GD::Image for the current list of supported Image formats.
.PP
The following class methods allow you to create new GD::Image objects.
.IP "\fB\f(CB$image\fB = GD::Image\->new([$width,$height],[$truecolor])\fR" 4
.IX Item "$image = GD::Image->new([$width,$height],[$truecolor])"
.PD 0
.IP "\fB\f(CB$image\fB = GD::Image\->new(*FILEHANDLE)\fR" 4
.IX Item "$image = GD::Image->new(*FILEHANDLE)"
.IP "\fB\f(CB$image\fB = GD::Image\->new($filename)\fR" 4
.IX Item "$image = GD::Image->new($filename)"
.IP "\fB\f(CB$image\fB = GD::Image\->new($data)\fR" 4
.IX Item "$image = GD::Image->new($data)"
.PD
The \fBnew()\fR method is the main constructor for the GD::Image class.
Called with two integer arguments, it creates a new blank image of the
specified width and height. For example:
.Sp
.Vb 1
\&        $myImage = GD::Image\->new(100,100) || die;
.Ve
.Sp
This will create an image that is 100 x 100 pixels wide.  If you don't
specify the dimensions, a default of 64 x 64 will be chosen.
.Sp
The optional third argument, \f(CW$truecolor\fR, tells \fBnew()\fR to create a
truecolor GD::Image object.  Truecolor images have 24 bits of color
data (eight bits each in the red, green and blue channels
respectively), allowing for precise photograph-quality color usage.
If not specified, the image will use an 8\-bit palette for
compatibility with older versions of libgd.
.Sp
Alternatively, you may create a GD::Image object based on an existing
image by providing an open filehandle, a filename, or the image data
itself.  The image formats automatically recognized and accepted are:
\&\s-1GIF, PNG, JPEG, XBM, XPM, GD2, TIFF, WEBP, HEIF\s0 or \s-1AVIF.\s0 Other formats,
including \s-1WBMP,\s0 and \s-1GD\s0 version 1, cannot be recognized automatically
at this time.
.Sp
If something goes wrong (e.g. insufficient memory), this call will
return undef.
.IP "\fB\f(CB$image\fB = GD::Image\->trueColor([0,1])\fR" 4
.IX Item "$image = GD::Image->trueColor([0,1])"
For backwards compatibility with scripts previous versions of \s-1GD,\s0
new images created from scratch (width, height) are palette based
by default.  To change this default to create true color images use:
.Sp
.Vb 1
\&        GD::Image\->trueColor(1);
.Ve
.Sp
before creating new images.  To switch back to palette
based by default, use:
.Sp
.Vb 1
\&        GD::Image\->trueColor(0);
.Ve
.IP "\fB\f(CB$image\fB = GD::Image\->newPalette([$width,$height])\fR" 4
.IX Item "$image = GD::Image->newPalette([$width,$height])"
.PD 0
.IP "\fB\f(CB$image\fB = GD::Image\->newTrueColor([$width,$height])\fR" 4
.IX Item "$image = GD::Image->newTrueColor([$width,$height])"
.PD
The \fBnewPalette()\fR and \fBnewTrueColor()\fR methods can be used to explicitly
create an palette based or true color image regardless of the
current setting of \fBtrueColor()\fR.
.IP "\fB\f(CB$image\fB = GD::Image\->newFromPng($file, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromPng($file, [$truecolor])"
.PD 0
.IP "\fB\f(CB$image\fB = GD::Image\->newFromPngData($data, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromPngData($data, [$truecolor])"
.PD
The \fBnewFromPng()\fR method will create an image from a \s-1PNG\s0 file read in
through the provided filehandle or file path.  The filehandle must
previously have been opened on a valid \s-1PNG\s0 file or pipe.  If
successful, this call will return an initialized image which you can
then manipulate as you please.  If it fails, which usually happens if
the thing at the other end of the filehandle is not a valid \s-1PNG\s0 file,
the call returns undef.  Notice that the call doesn't automatically
close the filehandle for you.  But it does call \f(CW\*(C`binmode(FILEHANDLE)\*(C'\fR
for you, on platforms where this matters.
.Sp
You may use any of the following as the argument:
.Sp
.Vb 5
\&  1) a simple filehandle, such as STDIN
\&  2) a filehandle glob, such as *PNG
\&  3) a reference to a glob, such as \e*PNG
\&  4) an IO::Handle object
\&  5) the pathname of a file
.Ve
.Sp
In the latter case, \fBnewFromPng()\fR will attempt to open the file for you
and read the \s-1PNG\s0 information from it.
.Sp
.Vb 1
\&  Example1:
\&
\&  open (PNG,"barnswallow.png") || die;
\&  $myImage = GD::Image\->newFromPng(\e*PNG) || die;
\&  close PNG;
\&
\&  Example2:
\&  $myImage = GD::Image\->newFromPng(\*(Aqbarnswallow.png\*(Aq);
.Ve
.Sp
To get information about the size and color usage of the information,
you can call the image query methods described below. Images created
by reading \s-1PNG\s0 images will be truecolor if the image file itself is
truecolor. To force the image to be palette-based, pass a value of 0
in the optional \f(CW$truecolor\fR argument.
.Sp
The \fBnewFromPngData()\fR method will create a new GD::Image initialized
with the \s-1PNG\s0 format \fBdata\fR contained in \f(CW$data\fR.
.IP "\fB\f(CB$image\fB = GD::Image\->newFromJpeg($file, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromJpeg($file, [$truecolor])"
.PD 0
.IP "\fB\f(CB$image\fB = GD::Image\->newFromJpegData($data, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromJpegData($data, [$truecolor])"
.PD
These methods will create an image from a \s-1JPEG\s0 file.  They work just
like \fBnewFromPng()\fR and \fBnewFromPngData()\fR, and will accept the same
filehandle and pathname arguments.
.Sp
Images created by reading \s-1JPEG\s0 images will always be truecolor.  To
force the image to be palette-based, pass a value of 0 in the optional
\&\f(CW$truecolor\fR argument.
.IP "\fB\f(CB$image\fB = GD::Image\->newFromGif($file, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromGif($file, [$truecolor])"
.PD 0
.IP "\fB\f(CB$image\fB = GD::Image\->newFromGifData($data)\fR" 4
.IX Item "$image = GD::Image->newFromGifData($data)"
.PD
These methods will create an image from a \s-1GIF\s0 file.  They work just
like \fBnewFromPng()\fR and \fBnewFromPngData()\fR, and will accept the same
filehandle and pathname arguments.
.Sp
Images created from GIFs are always 8\-bit palette images. To convert
to truecolor, you must create a truecolor image and then perform a
copy.
.IP "\fB\f(CB$image\fB = GD::Image\->newFromXbm($file, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromXbm($file, [$truecolor])"
This works in exactly the same way as \f(CW\*(C`newFromPng\*(C'\fR, but reads the
contents of an X Bitmap (black & white) file:
.Sp
.Vb 3
\&        open (XBM,"coredump.xbm") || die;
\&        $myImage = GD::Image\->newFromXbm(\e*XBM) || die;
\&        close XBM;
.Ve
.Sp
There is no \fBnewFromXbmData()\fR function, because there is no
corresponding function in the gd library.
.IP "\fB\f(CB$image\fB = GD::Image\->newFromWBMP($file, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromWBMP($file, [$truecolor])"
This works in exactly the same way as \f(CW\*(C`newFromPng\*(C'\fR, but reads the
contents of an Windows \s-1BMP\s0 Bitmap file:
.Sp
.Vb 3
\&        open (BMP,"coredump.bmp") || die;
\&        $myImage = GD::Image\->newFromWBMP(\e*BMP) || die;
\&        close BMP;
.Ve
.Sp
There is no \fBnewFromWBMPData()\fR function, because there is no
corresponding function in the gd library.
.IP "\fB\f(CB$image\fB = GD::Image\->newFromGd($file)\fR" 4
.IX Item "$image = GD::Image->newFromGd($file)"
.PD 0
.IP "\fB\f(CB$image\fB = GD::Image\->newFromGdData($data)\fR" 4
.IX Item "$image = GD::Image->newFromGdData($data)"
.PD
\&\s-1NOTE: GD\s0 and \s-1GD2\s0 support was dropped witn libgd 2.3.2.
.Sp
These methods initialize a GD::Image from a Gd file, filehandle, or
data.  Gd is Tom Boutell's disk-based storage format, intended for the
rare case when you need to read and write the image to disk quickly.
It's not intended for regular use, because, unlike \s-1PNG\s0 or \s-1JPEG,\s0 no
image compression is performed and these files can become \fB\s-1BIG\s0\fR.
.Sp
.Vb 2
\&        $myImage = GD::Image\->newFromGd("godzilla.gd") || die;
\&        close GDF;
.Ve
.IP "\fB\f(CB$image\fB = GD::Image\->newFromGd2($file)\fR" 4
.IX Item "$image = GD::Image->newFromGd2($file)"
.PD 0
.IP "\fB\f(CB$image\fB = GD::Image\->newFromGd2Data($data)\fR" 4
.IX Item "$image = GD::Image->newFromGd2Data($data)"
.PD
\&\s-1NOTE: GD\s0 and \s-1GD2\s0 support was dropped witn libgd 2.3.2.
.Sp
This works in exactly the same way as \f(CW\*(C`newFromGd()\*(C'\fR and
newFromGdData, but use the new compressed \s-1GD2\s0 image format.
.IP "\fB\f(CB$image\fB = GD::Image\->newFromGd2Part($file,srcX,srcY,width,height)\fR" 4
.IX Item "$image = GD::Image->newFromGd2Part($file,srcX,srcY,width,height)"
This class method allows you to read in just a portion of a \s-1GD2\s0 image
file.  In addition to a filehandle, it accepts the top-left corner and
dimensions (width,height) of the region of the image to read.  For
example:
.Sp
.Vb 3
\&        open (GDF,"godzilla.gd2") || die;
\&        $myImage = GD::Image\->newFromGd2Part(\e*GDF,10,20,100,100) || die;
\&        close GDF;
.Ve
.Sp
This reads a 100x100 square portion of the image starting from
position (10,20).
.IP "\fB\f(CB$image\fB = GD::Image\->newFromXpm($filename)\fR" 4
.IX Item "$image = GD::Image->newFromXpm($filename)"
This creates a new GD::Image object starting from a \fBfilename\fR.  This
is unlike the other \fBnewFrom()\fR functions because it does not take a
filehandle.  This difference comes from an inconsistency in the
underlying gd library.
.Sp
.Vb 1
\&        $myImage = GD::Image\->newFromXpm(\*(Aqearth.xpm\*(Aq) || die;
.Ve
.Sp
This function is only available if libgd was compiled with \s-1XPM\s0
support.
.Sp
\&\s-1NOTE:\s0 The libgd library is unable to read certain \s-1XPM\s0 files, returning
an all-black image instead.
.IP "\fB\f(CB$bool\fB = GD::supportsFileType($filename, \f(CB$is_writing\fB)\fR" 4
.IX Item "$bool = GD::supportsFileType($filename, $is_writing)"
This returns a \s-1TRUE\s0 or \s-1FALSE\s0 value, if libgd supports reading or when
the 2nd argument is 1, if libgd supports writing the given filetype,
depending on the filename extension. Only with libgd versions >= gd\-2.1.1.
.Sp
Assuming LibGD is compiled with support for these image types, the
following extensions are supported:
.Sp
.Vb 10
\&    .gif
\&    .gd, .gd2
\&    .wbmp
\&    .bmp
\&    .xbm
\&    .tga
\&    .png
\&    .jpg, .jpeg
\&    .tiff, .tif
\&    .webp
\&    .heic, .heix
\&    .avif
\&    .xpm
.Ve
.Sp
Filenames are parsed case-insensitively.
\&.avifs is not yet suppurted upstream in libavif.
.SH "GD::Image Methods"
.IX Header "GD::Image Methods"
Once a GD::Image object is created, you can draw with it, copy it, and
merge two images.  When you are finished manipulating the object, you
can convert it into a standard image file format to output or save to
a file.
.SS "Image Data Output Methods"
.IX Subsection "Image Data Output Methods"
The following methods convert the internal drawing format into
standard output file formats.
.IP "\fB\f(CB$pngdata\fB = \f(CB$image\fB\->png([$compression_level])\fR" 4
.IX Item "$pngdata = $image->png([$compression_level])"
This returns the image data in \s-1PNG\s0 format.  You can then print it,
pipe it to a display program, or write it to a file.  Example:
.Sp
.Vb 5
\&        $png_data = $myImage\->png;
\&        open (DISPLAY,"| display \-") || die;
\&        binmode DISPLAY;
\&        print DISPLAY $png_data;
\&        close DISPLAY;
.Ve
.Sp
Note the use of \f(CW\*(C`binmode()\*(C'\fR.  This is crucial for portability to
DOSish platforms.
.Sp
The optional \f(CW$compression_level\fR argument controls the amount of
compression to apply to the output \s-1PNG\s0 image.  Values range from 0\-9,
where 0 means no compression (largest files, highest quality) and 9
means maximum compression (smallest files, worst quality).  A
compression level of \-1 uses the default compression level selected
when zlib was compiled on your system, and is the same as calling
\&\fBpng()\fR with no argument.  Be careful not to confuse this argument with
the \fBjpeg()\fR quality argument, which ranges from 0\-100 and has the
opposite meaning from compression (higher numbers give higher
quality).
.IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->gifanimbegin([$GlobalCM [, \f(CB$Loops\fB]])\fR" 4
.IX Item "$gifdata = $image->gifanimbegin([$GlobalCM [, $Loops]])"
For libgd version 2.0.33 and higher, this call begins an animated \s-1GIF\s0
by returning the data that comprises animated gif image file header.
After you call this method, call \fBgifanimadd()\fR one or more times to add
the frames of the image. Then call \fBgifanimend()\fR. Each frame must be
the same width and height.
.Sp
A typical sequence will look like this:
.Sp
.Vb 10
\&  my $gifdata = $image\->gifanimbegin;
\&  $gifdata   .= $image\->gifanimadd;    # first frame
\&  for (1..100) {
\&     # make a frame of right size
\&     my $frame  = GD::Image\->new($image\->getBounds);
\&     add_frame_data($frame);              # add the data for this frame
\&     $gifdata   .= $frame\->gifanimadd;     # add frame
\&  }
\&  $gifdata   .= $image\->gifanimend;   # finish the animated GIF
\&  print $gifdata;                     # write animated gif to STDOUT
.Ve
.Sp
If you do not wish to store the data in memory, you can print it to
stdout or a file.
.Sp
The image that you call gifanimbegin on is used to set the image size,
color resolution and color map.  If argument \f(CW$GlobalCM\fR is 1, the image
color map becomes the GIF89a global color map.  If \f(CW$Loops\fR is given and
>= 0, the \s-1NETSCAPE2.0\s0 application extension is created, with looping
count.  Looping count 0 means forever.
.IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->gifanimadd([$LocalCM [, \f(CB$LeftOfs\fB [, \f(CB$TopOfs\fB [, \f(CB$Delay\fB [, \f(CB$Disposal\fB [, \f(CB$previm\fB]]]]]])\fR" 4
.IX Item "$gifdata = $image->gifanimadd([$LocalCM [, $LeftOfs [, $TopOfs [, $Delay [, $Disposal [, $previm]]]]]])"
Returns the data that comprises one animated gif image frame.  You can
then print it, pipe it to a display program, or write it to a file.
With \f(CW$LeftOfs\fR and \f(CW$TopOfs\fR you can place this frame in different offset
than (0,0) inside the image screen.  Delay between the previous frame
and this frame is in 1/100s units.  Disposal is usually and by default
1.  Compression is activated by giving the previous image as a
parameter.  This function then compares the images and only writes the
changed pixels to the new frame in animation.  The Disposal parameter
for optimized animations must be set to 1, also for the first frame.
\&\f(CW$LeftOfs\fR and \f(CW$TopOfs\fR parameters are ignored for optimized frames.
.IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->\fBgifanimend()\fB\fR" 4
.IX Item "$gifdata = $image->gifanimend()"
Returns the data for end segment of animated gif file.  It always
returns string ';'.  This string must be printed to an animated gif
file after all image frames to properly terminate it according to \s-1GIF\s0
file syntax.  Image object is not used at all in this method.
.IP "\fB\f(CB$jpegdata\fB = \f(CB$image\fB\->jpeg([$quality])\fR" 4
.IX Item "$jpegdata = $image->jpeg([$quality])"
This returns the image data in \s-1JPEG\s0 format.  You can then print it,
pipe it to a display program, or write it to a file.  You may pass an
optional quality score to \fBjpeg()\fR in order to control the \s-1JPEG\s0 quality.
This should be an integer between 0 and 100.  Higher quality scores
give larger files and better image quality.  If you don't specify the
quality, \fBjpeg()\fR will choose a good default.
.IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->\fBgif()\fB\fR." 4
.IX Item "$gifdata = $image->gif()."
This returns the image data in \s-1GIF\s0 format.  You can then print it,
pipe it to a display program, or write it to a file.
.IP "\fB\f(CB$gddata\fB = \f(CB$image\fB\->gd\fR" 4
.IX Item "$gddata = $image->gd"
This returns the image data in \s-1GD\s0 format.  You can then print it,
pipe it to a display program, or write it to a file.  Example:
.Sp
.Vb 2
\&        binmode MYOUTFILE;
\&        print MYOUTFILE $myImage\->gd;
.Ve
.IP "\fB\f(CB$gd2data\fB = \f(CB$image\fB\->gd2\fR" 4
.IX Item "$gd2data = $image->gd2"
Same as \fBgd()\fR, except that it returns the data in compressed \s-1GD2\s0
format.
.IP "\fB\f(CB$wbmpdata\fB = \f(CB$image\fB\->wbmp([$foreground])\fR" 4
.IX Item "$wbmpdata = $image->wbmp([$foreground])"
This returns the image data in \s-1WBMP\s0 format, which is a black-and-white
image format.  Provide the index of the color to become the foreground
color.  All other pixels will be considered background.
.IP "\fB\f(CB$tiffdata\fB = \f(CB$image\fB\->\fBtiff()\fB\fR" 4
.IX Item "$tiffdata = $image->tiff()"
This returns the image data in \s-1TIFF\s0 format.
.IP "\fB\f(CB$webpdata\fB = \f(CB$image\fB\->webp([$quality])\fR" 4
.IX Item "$webpdata = $image->webp([$quality])"
This returns the image data in \s-1WEBP\s0 format, with the optional quality argument.
The default is 80, also chosen by the value \-1.
A quality value of >= 101 is considered Lossless.
.IP "\fB\f(CB$webpdata\fB = \f(CB$image\fB\->heif([$quality])\fR" 4
.IX Item "$webpdata = $image->heif([$quality])"
This returns the truecolor image data in \s-1HEIF\s0 format, with the
optional quality and speed arguments.
If truecolor is not set, this fails.
The default quality is 80, also chosen by the value \-1.
A quality value of 200 is considered Lossless.
.IP "\fB\f(CB$webpdata\fB = \f(CB$image\fB\->avif([$quality,$speed])\fR" 4
.IX Item "$webpdata = $image->avif([$quality,$speed])"
This returns the truecolor image data in \s-1AVIF\s0 format, with the
AVif encoder and 444 chroma, and the optional quality argument.
If truecolor is not set, this fails.
The default compression quality 1\-100 is \-1, the default speed 0\-10 is 6.
.IP "\fB\f(CB$success\fB = \f(CB$image\fB\->_file($filename)\fR" 4
.IX Item "$success = $image->_file($filename)"
Writes an image to a file in the format indicated by the filename, with
libgd versions >= gd\-2.1.1.
.Sp
File type is determined by the extension of the file name.  See
\&\f(CW\*(C`supportsFiletype\*(C'\fR for an overview of the parsing.
.Sp
For file types that require extra arguments, \f(CW\*(C`_file\*(C'\fR attempts to
use sane defaults:
.Sp
.Vb 6
\&  C<gdImageGd2> chunk size = 0, compression is enabled.
\&  C<gdImageJpeg>        quality = \-1 (i.e. the reasonable default)
\&  C<gdImageWBMP>        foreground is the darkest available color
\&  C<gdImageWEBP>        quality default
\&  C<gdImageHEIF>        quality default, codes = HEVC, chroma = 444
\&  C<gdImageAVIF>        quality default, speed = 6
.Ve
.Sp
Everything else is called with the two-argument function and so will
use the default values.
.Sp
\&\f(CW\*(C`_file\*(C'\fR and the underlying libgd \f(CW\*(C`gdImageFile\*(C'\fR has some rudimentary
error detection and will return \s-1FALSE\s0 (0) if a detectable error
occurred.  However, the image loaders do not normally return their
error status so a result of \s-1TRUE\s0 (1) does **not** mean the file was
saved successfully.
.SS "Color Control"
.IX Subsection "Color Control"
These methods allow you to control and manipulate the GD::Image color
table for palette, non-truecolor images.
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorAllocate(red,green,blue)\fR" 4
.IX Item "$index = $image->colorAllocate(red,green,blue)"
This allocates a color with the specified red, green and blue
components and returns its index in the color table, if specified.
The first color allocated in this way becomes the image's background
color.  (255,255,255) is white (all pixels on).  (0,0,0) is black (all
pixels off).  (255,0,0) is fully saturated red.  (127,127,127) is 50%
gray.  You can find plenty of examples in /usr/X11/lib/X11/rgb.txt.
.Sp
If no colors are allocated, then this function returns \-1.
.Sp
Example:
.Sp
.Vb 3
\&        $black = $myImage\->colorAllocate(0,0,0); #background color
\&        $white = $myImage\->colorAllocate(255,255,255);
\&        $peachpuff = $myImage\->colorAllocate(255,218,185);
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorAllocateAlpha(reg,green,blue,alpha)\fR" 4
.IX Item "$index = $image->colorAllocateAlpha(reg,green,blue,alpha)"
This allocates a color with the specified red, green, and blue components,
plus the specified alpha channel.  The alpha value may range from 0 (opaque)
to 127 (transparent).  The \f(CW\*(C`alphaBlending\*(C'\fR function changes the way this
alpha channel affects the resulting image.
.IP "\fB\f(CB$image\fB\->colorDeallocate(colorIndex)\fR" 4
.IX Item "$image->colorDeallocate(colorIndex)"
This marks the color at the specified index as being ripe for
reallocation.  The next time colorAllocate is used, this entry will be
replaced.  You can call this method several times to deallocate
multiple colors.  There's no function result from this call.
.Sp
Example:
.Sp
.Vb 2
\&        $myImage\->colorDeallocate($peachpuff);
\&        $peachy = $myImage\->colorAllocate(255,210,185);
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorClosest(red,green,blue)\fR" 4
.IX Item "$index = $image->colorClosest(red,green,blue)"
This returns the index of the color closest in the color table to the
red green and blue components specified.  If no colors have yet been
allocated, then this call returns \-1.
.Sp
Example:
.Sp
.Vb 1
\&        $apricot = $myImage\->colorClosest(255,200,180);
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorClosestAlpha(red,green,blue,alpha)\fR" 4
.IX Item "$index = $image->colorClosestAlpha(red,green,blue,alpha)"
This returns the index of the color closest in the color table to the
red green blue and alpha components specified.  If no colors have yet been
allocated, then this call returns \-1.
.Sp
Example:
.Sp
.Vb 1
\&        $apricot = $myImage\->colorClosestAlpha(255,200,180,0);
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorClosestHWB(red,green,blue)\fR" 4
.IX Item "$index = $image->colorClosestHWB(red,green,blue)"
This also attempts to return the color closest in the color table to the
red green and blue components specified. It uses a Hue/White/Black 
color representation to make the selected color more likely to match
human perceptions of similar colors.
.Sp
If no colors have yet been allocated, then this call returns \-1.
.Sp
Example:
.Sp
.Vb 1
\&        $mostred = $myImage\->colorClosestHWB(255,0,0);
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorExact(red,green,blue)\fR" 4
.IX Item "$index = $image->colorExact(red,green,blue)"
This returns the index of a color that exactly matches the specified
red green and blue components.  If such a color is not in the color
table, this call returns \-1.
.Sp
.Vb 2
\&        $rosey = $myImage\->colorExact(255,100,80);
\&        warn "Everything\*(Aqs coming up roses.\en" if $rosey >= 0;
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorExactAlpha(red,green,blue,alpha)\fR" 4
.IX Item "$index = $image->colorExactAlpha(red,green,blue,alpha)"
This returns the index of a color that exactly matches the specified
red green blue and alpha components.  If such a color is not in the color
table, this call returns \-1.
.Sp
.Vb 2
\&        $rosey = $myImage\->colorExactAlpha(255,100,80,0);
\&        warn "Everything\*(Aqs coming up roses.\en" if $rosey >= 0;
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorResolve(red,green,blue)\fR" 4
.IX Item "$index = $image->colorResolve(red,green,blue)"
This returns the index of a color that exactly matches the specified
red green and blue components.  If such a color is not in the color
table and there is room, then this method allocates the color in the
color table and returns its index.
.Sp
.Vb 2
\&        $rosey = $myImage\->colorResolve(255,100,80);
\&        warn "Everything\*(Aqs coming up roses.\en" if $rosey >= 0;
.Ve
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorResolveAlpha(red,green,blue,alpha)\fR" 4
.IX Item "$index = $image->colorResolveAlpha(red,green,blue,alpha)"
This returns the index of a color that exactly matches the specified
red green blue and alpha components.  If such a color is not in the color
table and there is room, then this method allocates the color in the
color table and returns its index.
.Sp
.Vb 2
\&        $rosey = $myImage\->colorResolveAlpha(255,100,80,0);
\&        warn "Everything\*(Aqs coming up roses.\en" if $rosey >= 0;
.Ve
.IP "\fB\f(CB$colorsTotal\fB = \f(CB$image\fB\->colorsTotal\fR \fIobject method\fR" 4
.IX Item "$colorsTotal = $image->colorsTotal object method"
This returns the total number of colors allocated in the object.
.Sp
.Vb 1
\&        $maxColors = $myImage\->colorsTotal;
.Ve
.Sp
In the case of a TrueColor image, this call will return undef.
.IP "\fB\f(CB$index\fB = \f(CB$image\fB\->getPixel(x,y)\fR \fIobject method\fR" 4
.IX Item "$index = $image->getPixel(x,y) object method"
This returns the color table index underneath the specified
point.  It can be combined with \fBrgb()\fR
to obtain the rgb color underneath the pixel.
.Sp
Example:
.Sp
.Vb 2
\&        $index = $myImage\->getPixel(20,100);
\&        ($r,$g,$b) = $myImage\->rgb($index);
.Ve
.IP "\fB($red,$green,$blue) = \f(CB$image\fB\->rgb($index)\fR" 4
.IX Item "($red,$green,$blue) = $image->rgb($index)"
This returns a list containing the red, green and blue components of
the specified color index.
.Sp
Example:
.Sp
.Vb 1
\&        @RGB = $myImage\->rgb($peachy);
.Ve
.IP "\fB($alpha) = \f(CB$image\fB\->alpha($index)\fR" 4
.IX Item "($alpha) = $image->alpha($index)"
This returns an item containing the alpha component of the specified
color index.
.Sp
Example:
.Sp
.Vb 1
\&        @RGB = $myImage\->rgb($peachy);
.Ve
.IP "\fB\f(CB$image\fB\->transparent($colorIndex)\fR" 4
.IX Item "$image->transparent($colorIndex)"
This marks the color at the specified index as being transparent.
Portions of the image drawn in this color will be invisible.  This is
useful for creating paintbrushes of odd shapes, as well as for
making \s-1PNG\s0 backgrounds transparent for displaying on the Web.  Only
one color can be transparent at any time. To disable transparency, 
specify \-1 for the index.
.Sp
If you call this method without any parameters, it will return the
current index of the transparent color, or \-1 if none.
.Sp
Example:
.Sp
.Vb 6
\&        open(PNG,"test.png");
\&        $im = GD::Image\->newFromPng(PNG);
\&        $white = $im\->colorClosest(255,255,255); # find white
\&        $im\->transparent($white);
\&        binmode STDOUT;
\&        print $im\->png;
.Ve
.SS "Special Colors"
.IX Subsection "Special Colors"
\&\s-1GD\s0 implements a number of special colors that can be used to achieve
special effects.  They are constants defined in the \s-1GD::\s0
namespace, but automatically exported into your namespace when the \s-1GD\s0
module is loaded.
.IP "\fB\f(CB$image\fB\->setBrush($image)\fR" 4
.IX Item "$image->setBrush($image)"
You can draw lines and shapes using a brush pattern.  Brushes are just
palette, not TrueColor, images that you can create and manipulate in
the usual way. When you draw with them, their contents are used for
the color and shape of the lines.
.Sp
To make a brushed line, you must create or load the brush first, then
assign it to the image using \fBsetBrush()\fR.  You can then draw in that
with that brush using the \fBgdBrushed\fR special color.  It's often
useful to set the background of the brush to transparent so that the
non-colored parts don't overwrite other parts of your image.
.Sp
Example:
.Sp
.Vb 6
\&        # Create a brush at an angle
\&        $diagonal_brush = GD::Image\->new(5,5);
\&        $white = $diagonal_brush\->colorAllocate(255,255,255);
\&        $black = $diagonal_brush\->colorAllocate(0,0,0);
\&        $diagonal_brush\->transparent($white);
\&        $diagonal_brush\->line(0,4,4,0,$black); # NE diagonal
\&
\&        # Set the brush
\&        $myImage\->setBrush($diagonal_brush);
\&        
\&        # Draw a circle using the brush
\&        $myImage\->arc(50,50,25,25,0,360,gdBrushed);
.Ve
.IP "\fB\f(CB$image\fB\->setThickness($thickness)\fR" 4
.IX Item "$image->setThickness($thickness)"
Lines drawn with \fBline()\fR, \fBrectangle()\fR, \fBarc()\fR, and so forth are 1 pixel
thick by default.  Call \fBsetThickness()\fR to change the line drawing
width.
.IP "\fB\f(CB$image\fB\->setStyle(@colors)\fR" 4
.IX Item "$image->setStyle(@colors)"
Styled lines consist of an arbitrary series of repeated colors and are
useful for generating dotted and dashed lines.  To create a styled
line, use \fBsetStyle()\fR to specify a repeating series of colors.  It
accepts an array consisting of one or more color indexes.  Then draw
using the \fBgdStyled\fR special color.  Another special color,
\&\fBgdTransparent\fR can be used to introduce holes in the line, as the
example shows.
.Sp
Example:
.Sp
.Vb 6
\&        # Set a style consisting of 4 pixels of yellow,
\&        # 4 pixels of blue, and a 2 pixel gap
\&        $myImage\->setStyle($yellow,$yellow,$yellow,$yellow,
\&                           $blue,$blue,$blue,$blue,
\&                           gdTransparent,gdTransparent);
\&        $myImage\->arc(50,50,25,25,0,360,gdStyled);
.Ve
.Sp
To combine the \f(CW\*(C`gdStyled\*(C'\fR and \f(CW\*(C`gdBrushed\*(C'\fR behaviors, you can specify
\&\f(CW\*(C`gdStyledBrushed\*(C'\fR.  In this case, a pixel from the current brush
pattern is rendered wherever the color specified in \fBsetStyle()\fR is
neither gdTransparent nor 0.
.IP "\fBgdTiled\fR" 4
.IX Item "gdTiled"
Draw filled shapes and flood fills using a pattern.  The pattern is
just another image.  The image will be tiled multiple times in order
to fill the required space, creating wallpaper effects.  You must call
\&\f(CW\*(C`setTile\*(C'\fR in order to define the particular tile pattern you'll use
for drawing when you specify the gdTiled color.
details.
.IP "\fBgdStyled\fR" 4
.IX Item "gdStyled"
The gdStyled color is used for creating dashed and dotted lines.  A
styled line can contain any series of colors and is created using the
\&\fBsetStyled()\fR command.
.IP "\fBgdAntiAliased\fR" 4
.IX Item "gdAntiAliased"
The \f(CW\*(C`gdAntiAliased\*(C'\fR color is used for drawing lines with antialiasing
turned on.  Antialiasing will blend the jagged edges of lines with the
background, creating a smoother look.  The actual color drawn is set
with \fBsetAntiAliased()\fR.
.IP "\fB\f(CB$image\fB\->setAntiAliased($color)\fR" 4
.IX Item "$image->setAntiAliased($color)"
\&\*(L"Antialiasing\*(R" is a process by which jagged edges associated with line
drawing can be reduced by blending the foreground color with an
appropriate percentage of the background, depending on how much of the
pixel in question is actually within the boundaries of the line being
drawn. All line-drawing methods, such as \fBline()\fR and polygon, will draw
antialiased lines if the special \*(L"color\*(R" \fBgdAntiAliased\fR is used when
calling them.
.Sp
\&\fBsetAntiAliased()\fR is used to specify the actual foreground color to be
used when drawing antialiased lines. You may set any color to be the
foreground, however as of libgd version 2.0.12 an alpha channel
component is not supported.
.Sp
Antialiased lines can be drawn on both truecolor and palette-based
images. However, attempts to draw antialiased lines on highly complex
palette-based backgrounds may not give satisfactory results, due to
the limited number of colors available in the palette. Antialiased
line-drawing on simple backgrounds should work well with palette-based
images; otherwise create or fetch a truecolor image instead. When
using palette-based images, be sure to allocate a broad spectrum of
colors in order to have sufficient colors for the antialiasing to use.
.IP "\fB\f(CB$image\fB\->setAntiAliasedDontBlend($color,[$flag])\fR" 4
.IX Item "$image->setAntiAliasedDontBlend($color,[$flag])"
Normally, when drawing lines with the special \fBgdAntiAliased\fR
\&\*(L"color,\*(R" blending with the background to reduce jagged edges is the
desired behavior. However, when it is desired that lines not be
blended with one particular color when it is encountered in the
background, the \fBsetAntiAliasedDontBlend()\fR method can be used to
indicate the special color that the foreground should stand out more
clearly against.
.Sp
Once turned on, you can turn this feature off by calling
\&\fBsetAntiAliasedDontBlend()\fR with a second argument of 0:
.Sp
.Vb 1
\&  $image\->setAntiAliasedDontBlend($color,0);
.Ve
.SS "Drawing Commands"
.IX Subsection "Drawing Commands"
These methods allow you to draw lines, rectangles, and ellipses, as
well as to perform various special operations like flood-fill.
.IP "\fB\f(CB$image\fB\->setPixel($x,$y,$color)\fR" 4
.IX Item "$image->setPixel($x,$y,$color)"
This sets the pixel at (x,y) to the specified color index.  No value
is returned from this method.  The coordinate system starts at the
upper left at (0,0) and gets larger as you go down and to the right.
You can use a real color, or one of the special colors gdBrushed, 
gdStyled and gdStyledBrushed can be specified.
.Sp
Example:
.Sp
.Vb 2
\&        # This assumes $peach already allocated
\&        $myImage\->setPixel(50,50,$peach);
.Ve
.IP "\fB\f(CB$image\fB\->line($x1,$y1,$x2,$y2,$color)\fR" 4
.IX Item "$image->line($x1,$y1,$x2,$y2,$color)"
This draws a line from (x1,y1) to (x2,y2) of the specified color.  You
can use a real color, or one of the special colors gdBrushed, 
gdStyled and gdStyledBrushed.
.Sp
Example:
.Sp
.Vb 3
\&        # Draw a diagonal line using the currently defined
\&        # paintbrush pattern.
\&        $myImage\->line(0,0,150,150,gdBrushed);
.Ve
.IP "\fB\f(CB$image\fB\->dashedLine($x1,$y1,$x2,$y2,$color)\fR" 4
.IX Item "$image->dashedLine($x1,$y1,$x2,$y2,$color)"
\&\s-1DEPRECATED:\s0 The libgd library provides this method solely for backward
compatibility with libgd version 1.0, and there have been reports that
it no longer works as expected. Please use the \fBsetStyle()\fR and gdStyled
methods as described below.
.Sp
This draws a dashed line from (x1,y1) to (x2,y2) in the specified
color.  A more powerful way to generate arbitrary dashed and dotted
lines is to use the \fBsetStyle()\fR method described below and to draw with
the special color gdStyled.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage\->dashedLine(0,0,150,150,$blue);
.Ve
.IP "\fB\f(CB$image\fB\->rectangle($x1,$y1,$x2,$y2,$color)\fR" 4
.IX Item "$image->rectangle($x1,$y1,$x2,$y2,$color)"
This draws a rectangle with the specified color.  (x1,y1) and (x2,y2)
are the upper left and lower right corners respectively.  Both real
color indexes and the special colors gdBrushed, gdStyled and
gdStyledBrushed are accepted.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage\->rectangle(10,10,100,100,$rose);
.Ve
.IP "\fB\f(CB$image\fB\->filledRectangle($x1,$y1,$x2,$y2,$color)\fR =item \fB\f(CB$image\fB\->setTile($otherimage)\fR" 4
.IX Item "$image->filledRectangle($x1,$y1,$x2,$y2,$color) =item $image->setTile($otherimage)"
This draws a rectangle filled with the specified color.  You can use a
real color, or the special fill color gdTiled to fill the polygon
with a pattern.
.Sp
Example:
.Sp
.Vb 3
\&        # read in a fill pattern and set it
\&        $tile = GD::Image\->newFromPng(\*(Aqhappyface.png\*(Aq);
\&        $myImage\->setTile($tile); 
\&
\&        # draw the rectangle, filling it with the pattern
\&        $myImage\->filledRectangle(10,10,150,200,gdTiled);
.Ve
.IP "\fB\f(CB$image\fB\->openPolygon($polygon,$color)\fR" 4
.IX Item "$image->openPolygon($polygon,$color)"
This draws a polygon with the specified color.  The polygon must be
created first (see below).  The polygon must have at least three
vertices.  If the last vertex doesn't close the polygon, the method
will close it for you.  Both real color indexes and the special 
colors gdBrushed, gdStyled and gdStyledBrushed can be specified.
.Sp
Example:
.Sp
.Vb 5
\&        $poly = GD::Polygon\->new;
\&        $poly\->addPt(50,0);
\&        $poly\->addPt(99,99);
\&        $poly\->addPt(0,99);
\&        $myImage\->openPolygon($poly,$blue);
.Ve
.IP "\fB\f(CB$image\fB\->unclosedPolygon($polygon,$color)\fR" 4
.IX Item "$image->unclosedPolygon($polygon,$color)"
This draws a sequence of connected lines with the specified color,
without connecting the first and last point to a closed polygon.  The
polygon must be created first (see below).  The polygon must have at
least three vertices.  Both real color indexes and the special colors
gdBrushed, gdStyled and gdStyledBrushed can be specified.
.Sp
You need libgd 2.0.33 or higher to use this feature.
.Sp
Example:
.Sp
.Vb 5
\&        $poly = GD::Polygon\->new;
\&        $poly\->addPt(50,0);
\&        $poly\->addPt(99,99);
\&        $poly\->addPt(0,99);
\&        $myImage\->unclosedPolygon($poly,$blue);
.Ve
.IP "\fB\f(CB$image\fB\->filledPolygon($poly,$color)\fR" 4
.IX Item "$image->filledPolygon($poly,$color)"
This draws a polygon filled with the specified color.  You can use a
real color, or the special fill color gdTiled to fill the polygon
with a pattern.
.Sp
Example:
.Sp
.Vb 5
\&        # make a polygon
\&        $poly = GD::Polygon\->new;
\&        $poly\->addPt(50,0);
\&        $poly\->addPt(99,99);
\&        $poly\->addPt(0,99);
\&
\&        # draw the polygon, filling it with a color
\&        $myImage\->filledPolygon($poly,$peachpuff);
.Ve
.IP "\fB\f(CB$image\fB\->ellipse($cx,$cy,$width,$height,$color)\fR" 4
.IX Item "$image->ellipse($cx,$cy,$width,$height,$color)"
.PD 0
.IP "\fB\f(CB$image\fB\->filledEllipse($cx,$cy,$width,$height,$color)\fR" 4
.IX Item "$image->filledEllipse($cx,$cy,$width,$height,$color)"
.PD
These \fBmethods()\fR draw ellipses. ($cx,$cy) is the center of the arc, and
($width,$height) specify the ellipse width and height, respectively.
\&\fBfilledEllipse()\fR is like \fBEllipse()\fR except that the former produces
filled versions of the ellipse.
.IP "\fB\f(CB$image\fB\->arc($cx,$cy,$width,$height,$start,$end,$color)\fR" 4
.IX Item "$image->arc($cx,$cy,$width,$height,$start,$end,$color)"
This draws arcs and ellipses.  (cx,cy) are the center of the arc, and
(width,height) specify the width and height, respectively.  The
portion of the ellipse covered by the arc are controlled by start and
end, both of which are given in degrees from 0 to 360.  Zero is at the
right end of the ellipse, and angles increase clockwise.  To specify a
complete ellipse, use 0 and 360 as the starting and ending angles.  To
draw a circle, use the same value for width and height.
.Sp
You can specify a normal color or one of the special colors
\&\fBgdBrushed\fR, \fBgdStyled\fR, or \fBgdStyledBrushed\fR.
.Sp
Example:
.Sp
.Vb 2
\&        # draw a semicircle centered at 100,100
\&        $myImage\->arc(100,100,50,50,0,180,$blue);
.Ve
.IP "\fB\f(CB$image\fB\->filledArc($cx,$cy,$width,$height,$start,$end,$color [,$arc_style])\fR" 4
.IX Item "$image->filledArc($cx,$cy,$width,$height,$start,$end,$color [,$arc_style])"
This method is like \fBarc()\fR except that it colors in the pie wedge with
the selected color.  \f(CW$arc_style\fR is optional.  If present it is a
bitwise \s-1OR\s0 of the following constants:
.Sp
.Vb 5
\&  gdArc           connect start & end points of arc with a rounded edge
\&  gdChord         connect start & end points of arc with a straight line
\&  gdPie           synonym for gdChord
\&  gdNoFill        outline the arc or chord
\&  gdEdged         connect beginning and ending of the arc to the center
.Ve
.Sp
gdArc and gdChord are mutually exclusive.  gdChord just connects the
starting and ending angles with a straight line, while gdArc produces
a rounded edge. gdPie is a synonym for gdArc. gdNoFill indicates that
the arc or chord should be outlined, not filled. gdEdged, used
together with gdNoFill, indicates that the beginning and ending angles
should be connected to the center; this is a good way to outline
(rather than fill) a \*(L"pie slice.\*(R"
.Sp
Example:
.Sp
.Vb 1
\&  $image\->filledArc(100,100,50,50,0,90,$blue,gdEdged|gdNoFill);
.Ve
.IP "\fB\f(CB$image\fB\->fill($x,$y,$color)\fR" 4
.IX Item "$image->fill($x,$y,$color)"
This method flood-fills regions with the specified color.  The color
will spread through the image, starting at point (x,y), until it is
stopped by a pixel of a different color from the starting pixel (this
is similar to the \*(L"paintbucket\*(R" in many popular drawing toys).  You
can specify a normal color, or the special color gdTiled, to flood-fill
with patterns.
.Sp
Example:
.Sp
.Vb 3
\&        # Draw a rectangle, and then make its interior blue
\&        $myImage\->rectangle(10,10,100,100,$black);
\&        $myImage\->fill(50,50,$blue);
.Ve
.IP "\fB\f(CB$image\fB\->fillToBorder($x,$y,$bordercolor,$color)\fR" 4
.IX Item "$image->fillToBorder($x,$y,$bordercolor,$color)"
Like \f(CW\*(C`fill\*(C'\fR, this method flood-fills regions with the specified
color, starting at position (x,y).  However, instead of stopping when
it hits a pixel of a different color than the starting pixel, flooding
will only stop when it hits the color specified by bordercolor.  You
must specify a normal indexed color for the bordercolor.  However, you
are free to use the gdTiled color for the fill.
.Sp
Example:
.Sp
.Vb 3
\&        # This has the same effect as the previous example
\&        $myImage\->rectangle(10,10,100,100,$black);
\&        $myImage\->fillToBorder(50,50,$black,$blue);
.Ve
.SS "Image Copying Commands"
.IX Subsection "Image Copying Commands"
Two methods are provided for copying a rectangular region from one
image to another.  One method copies a region without resizing it.
The other allows you to stretch the region during the copy operation.
.PP
With either of these methods it is important to know that the routines
will attempt to flesh out the destination image's color table to match
the colors that are being copied from the source.  If the
destination's color table is already full, then the routines will
attempt to find the best match, with varying results.
.IP "\fB\f(CB$image\fB\->copy($sourceImage,$dstX,$dstY,$srcX,$srcY,$width,$height)\fR" 4
.IX Item "$image->copy($sourceImage,$dstX,$dstY,$srcX,$srcY,$width,$height)"
This is the simplest of the several copy operations, copying the
specified region from the source image to the destination image (the
one performing the method call).  (srcX,srcY) specify the upper left
corner of a rectangle in the source image, and (width,height) give the
width and height of the region to copy.  (dstX,dstY) control where in
the destination image to stamp the copy.  You can use the same image
for both the source and the destination, but the source and
destination regions must not overlap or strange things will happen.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = GD::Image\->new(100,100);
\&        ... various drawing stuff ...
\&        $srcImage = GD::Image\->new(50,50);
\&        ... more drawing stuff ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # the rectangle starting at (10,10) in $myImage
\&        $myImage\->copy($srcImage,10,10,0,0,25,25);
.Ve
.IP "\fB\f(CB$image\fB\->\fBclone()\fB\fR" 4
.IX Item "$image->clone()"
Make a copy of the image and return it as a new object.  The new image
will look identical.  However, it may differ in the size of the color
palette and other nonessential details.
.Sp
Example:
.Sp
.Vb 3
\&        $myImage = GD::Image\->new(100,100);
\&        ... various drawing stuff ...
\&        $copy = $myImage\->clone;
.Ve
.IP "\fB\f(CB$image\fB\->copyMerge($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyMerge($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$width,$height,$percent)\fR
.Sp
This copies the indicated rectangle from the source image to the
destination image, merging the colors to the extent specified by
percent (an integer between 0 and 100).  Specifying 100% has the same
effect as \fBcopy()\fR \*(-- replacing the destination pixels with the source
image.  This is most useful for highlighting an area by merging in a
solid rectangle.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = GD::Image\->new(100,100);
\&        ... various drawing stuff ...
\&        $redImage = GD::Image\->new(50,50);
\&        ... more drawing stuff ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # the rectangle starting at (10,10) in $myImage, merging 50%
\&        $myImage\->copyMerge($srcImage,10,10,0,0,25,25,50);
.Ve
.IP "\fB\f(CB$image\fB\->copyMergeGray($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyMergeGray($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$width,$height,$percent)\fR
.Sp
This is identical to \fBcopyMerge()\fR except that it preserves the hue of
the source by converting all the pixels of the destination rectangle
to grayscale before merging.
.IP "\fB\f(CB$image\fB\->copyResized($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyResized($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$destW,$destH,$srcW,$srcH)\fR
.Sp
This method is similar to \fBcopy()\fR but allows you to choose different
sizes for the source and destination rectangles.  The source and
destination rectangle's are specified independently by (srcW,srcH) and
(destW,destH) respectively.  \fBcopyResized()\fR will stretch or shrink the
image to accommodate the size requirements.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = GD::Image\->new(100,100);
\&        ... various drawing stuff ...
\&        $srcImage = GD::Image\->new(50,50);
\&        ... more drawing stuff ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # a larger rectangle starting at (10,10) in $myImage
\&        $myImage\->copyResized($srcImage,10,10,0,0,50,50,25,25);
.Ve
.IP "\fB\f(CB$image\fB\->copyResampled($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyResampled($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$destW,$destH,$srcW,$srcH)\fR
.Sp
This method is similar to \fBcopyResized()\fR but provides \*(L"smooth\*(R" copying
from a large image to a smaller one, using a weighted average of the
pixels of the source area rather than selecting one representative
pixel. This method is identical to \fBcopyResized()\fR when the destination
image is a palette image.
.IP "\fB\f(CB$image\fB\->copyRotated($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyRotated($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$width,$height,$angle)\fR
.Sp
Like \fBcopyResized()\fR but the \f(CW$angle\fR argument specifies an arbitrary
amount to rotate the image counter clockwise (in degrees).  In addition, \f(CW$dstX\fR
and \f(CW$dstY\fR species the \fBcenter\fR of the destination image, and not the
top left corner.
.IP "\fB\f(CB$image\fB\->trueColorToPalette([$dither], [$colors])\fR" 4
.IX Item "$image->trueColorToPalette([$dither], [$colors])"
This method converts a truecolor image to a palette image. The code for
this function was originally drawn from the Independent \s-1JPEG\s0 Group library
code, which is excellent. The code has been modified to preserve as much
alpha channel information as possible in the resulting palette, in addition
to preserving colors as well as possible. This does not work as well as
might be hoped. It is usually best to simply produce a truecolor
output image instead, which guarantees the highest output quality.
Both the dithering (0/1, default=0) and maximum number of colors used
(<=256, default = gdMaxColors) can be specified.
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->createPaletteFromTrueColor([$dither], [$colors])\fR" 4
.IX Item "$image = $sourceImage->createPaletteFromTrueColor([$dither], [$colors])"
Creates a new palette image from a truecolor image. Same as above, but
returns a new image.
.Sp
Don't use these function \*(-- write real truecolor PNGs and JPEGs. The
disk space gain of conversion to palette is not great (for small
images it can be negative) and the quality loss is ugly.
.IP "\fB\f(CB$error\fB = \f(CB$image\fB\->colorMatch($otherimage)\fR" 4
.IX Item "$error = $image->colorMatch($otherimage)"
Bring the palette colors in \f(CW$otherimage\fR to be closer to truecolor \f(CW$image\fR.
A negative return value is a failure.
.Sp
.Vb 4
\&  \-1 image must be True Color
\&  \-2 otherimage must be indexed
\&  \-3 the images are meant to be the same dimensions
\&  \-4 At least 1 color in otherimage must be allocated
.Ve
.Sp
This method is only available with libgd >= 2.1.0
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->neuQuant($maxcolor=256,$samplefactor=5)\fR" 4
.IX Item "$image = $sourceImage->neuQuant($maxcolor=256,$samplefactor=5)"
Creates a new palette image from a truecolor image.
.RS 4
.IP "samplefactor	The quantization precision between 1 (highest quality) and 10 (fastest)." 4
.IX Item "samplefactor The quantization precision between 1 (highest quality) and 10 (fastest)."
.PD 0
.IP "maxcolor	The number of desired palette entries." 4
.IX Item "maxcolor The number of desired palette entries."
.RE
.RS 4
.PD
.Sp
This is the same as createPaletteFromTrueColor with the
quantization method \s-1GD_QUANT_NEUQUANT.\s0 This does not support dithering.
This method is only available with libgd >= 2.1.0
.RE
.SS "Image Transformation Commands"
.IX Subsection "Image Transformation Commands"
Gd provides these simple image transformations, non-interpolated.
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\fBcopyRotate90()\fB\fR" 4
.IX Item "$image = $sourceImage->copyRotate90()"
.PD 0
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\fBcopyRotate180()\fB\fR" 4
.IX Item "$image = $sourceImage->copyRotate180()"
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\fBcopyRotate270()\fB\fR" 4
.IX Item "$image = $sourceImage->copyRotate270()"
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\fBcopyFlipHorizontal()\fB\fR" 4
.IX Item "$image = $sourceImage->copyFlipHorizontal()"
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\fBcopyFlipVertical()\fB\fR" 4
.IX Item "$image = $sourceImage->copyFlipVertical()"
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\fBcopyTranspose()\fB\fR" 4
.IX Item "$image = $sourceImage->copyTranspose()"
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\fBcopyReverseTranspose()\fB\fR" 4
.IX Item "$image = $sourceImage->copyReverseTranspose()"
.PD
These methods can be used to rotate, flip, or transpose an image.
The result of the method is a copy of the image.
.IP "\fB\f(CB$image\fB\->\fBrotate180()\fB\fR" 4
.IX Item "$image->rotate180()"
.PD 0
.IP "\fB\f(CB$image\fB\->\fBflipHorizontal()\fB\fR" 4
.IX Item "$image->flipHorizontal()"
.IP "\fB\f(CB$image\fB\->\fBflipVertical()\fB\fR" 4
.IX Item "$image->flipVertical()"
.PD
These methods are similar to the copy* versions, but instead
modify the image in place.
.SS "Image Interpolation Methods"
.IX Subsection "Image Interpolation Methods"
Since libgd 2.1.0 there are better transformation methods, with
these interpolation methods:
.PP
.Vb 10
\&  GD_BELL                \- Bell
\&  GD_BESSEL              \- Bessel
\&  GD_BILINEAR_FIXED      \- fixed point bilinear
\&  GD_BICUBIC             \- Bicubic
\&  GD_BICUBIC_FIXED       \- fixed point bicubic integer
\&  GD_BLACKMAN            \- Blackman
\&  GD_BOX                 \- Box
\&  GD_BSPLINE             \- BSpline
\&  GD_CATMULLROM          \- Catmullrom
\&  GD_GAUSSIAN            \- Gaussian
\&  GD_GENERALIZED_CUBIC   \- Generalized cubic
\&  GD_HERMITE             \- Hermite
\&  GD_HAMMING             \- Hamming
\&  GD_HANNING             \- Hannig
\&  GD_MITCHELL            \- Mitchell
\&  GD_NEAREST_NEIGHBOUR   \- Nearest neighbour interpolation
\&  GD_POWER               \- Power
\&  GD_QUADRATIC           \- Quadratic
\&  GD_SINC                \- Sinc
\&  GD_TRIANGLE            \- Triangle
\&  GD_WEIGHTED4           \- 4 pixels weighted bilinear interpolation
\&  GD_LINEAR              \- bilinear interpolation
.Ve
.IP "\fB\f(CB$image\fB\->interpolationMethod( [$method] )\fR" 4
.IX Item "$image->interpolationMethod( [$method] )"
Gets or sets the interpolation methods for all subsequent interpolations.
See above for the valid values.
Only available since libgd 2.2.0
.IP "\fB\f(CB$image\fB\->copyScaleInterpolated( width, height )\fR" 4
.IX Item "$image->copyScaleInterpolated( width, height )"
Returns a copy, using interpolation.
.IP "\fB\f(CB$image\fB\->copyRotateInterpolated( angle, bgcolor )\fR" 4
.IX Item "$image->copyRotateInterpolated( angle, bgcolor )"
Returns a copy, using interpolation.
.SS "Image Filter Commands"
.IX Subsection "Image Filter Commands"
Gd also provides some common image filters, they modify the image in
place and return \s-1TRUE\s0 if modified or \s-1FALSE\s0 if not.
Most of them need libgd >= 2.1.0, with older versions those functions are undefined.
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->scatter($sub, \f(CB$plus\fB)\fR" 4
.IX Item "$ok = $image->scatter($sub, $plus)"
if \f(CW$sub\fR and \f(CW$plus\fR are 0, nothing is changed, \s-1TRUE\s0 is returned.
if \f(CW$sub\fR >= \f(CW$plus\fR, nothing is changed, \s-1FALSE\s0 is returned.
else random pixels are changed.
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->scatterColor($sub, \f(CB$plus\fB, \f(CB@colors\fB)\fR" 4
.IX Item "$ok = $image->scatterColor($sub, $plus, @colors)"
Similar to scatter, but using the given array of colors,
i.e. palette indices.
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->pixelate($blocksize, \f(CB$mode\fB)\fR" 4
.IX Item "$ok = $image->pixelate($blocksize, $mode)"
if \f(CW$blocksize\fR <= 0, nothing is changed, \s-1FALSE\s0 is returned.
if \f(CW$blocksize\fR == 1, nothing is changed, \s-1TRUE\s0 is returned.
else the following modes are observed:
  \s-1GD_PIXELATE_UPPERLEFT\s0
  \s-1GD_PIXELATE_AVERAGE\s0
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->\fBnegate()\fB\fR" 4
.IX Item "$ok = $image->negate()"
.PD 0
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->\fBgrayscale()\fB\fR" 4
.IX Item "$ok = $image->grayscale()"
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->brightness($add)\fR" 4
.IX Item "$ok = $image->brightness($add)"
.PD
\&\f(CW$add:\fR \-255..255
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->contrast($contrast)\fR" 4
.IX Item "$ok = $image->contrast($contrast)"
\&\f(CW$contrast:\fR a double value. The contrast adjustment value. Negative
values increase, positive values decrease the contrast. The larger
the absolute value, the stronger the effect.
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->color($red,$green,$blue,$alpha)\fR" 4
.IX Item "$ok = $image->color($red,$green,$blue,$alpha)"
Change channel values of an image.
.Sp
.Vb 4
\&  $red   \- The value to add to the red channel of all pixels.
\&  $green \- The value to add to the green channel of all pixels.
\&  $blue  \- The value to add to the blue channel of all pixels.
\&  $alpha \- The value to add to the alpha channel of all pixels.
.Ve
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->\fBselectiveBlur()\fB\fR" 4
.IX Item "$ok = $image->selectiveBlur()"
.PD 0
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->\fBedgeDetectQuick()\fB\fR" 4
.IX Item "$ok = $image->edgeDetectQuick()"
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->\fBgaussianBlur()\fB\fR" 4
.IX Item "$ok = $image->gaussianBlur()"
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->\fBemboss()\fB\fR" 4
.IX Item "$ok = $image->emboss()"
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->\fBmeanRemoval()\fB\fR" 4
.IX Item "$ok = $image->meanRemoval()"
.IP "\fB\f(CB$ok\fB = \f(CB$image\fB\->smooth($weight)\fR" 4
.IX Item "$ok = $image->smooth($weight)"
.IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->copyGaussianBlurred($radius, \f(CB$sigma\fB)\fR" 4
.IX Item "$image = $sourceImage->copyGaussianBlurred($radius, $sigma)"
.PD
\&\f(CW$radius:\fR int, the blur radius (*not* diameter\*(--range is 2*radius + 1)
a radius, not a diameter so a radius of 2 (for example) will blur
across a region 5 pixels across (2 to the center, 1 for the center
itself and another 2 to the other edge).
.Sp
\&\f(CW$sigma:\fR the sigma value or a value <= 0.0 to use the computed default.
represents the \*(L"fatness\*(R" of the curve (lower == fatter).
.Sp
The result is always truecolor.
.SS "Character and String Drawing"
.IX Subsection "Character and String Drawing"
\&\s-1GD\s0 allows you to draw characters and strings, either in normal
horizontal orientation or rotated 90 degrees.  These routines use a
GD::Font object, described in more detail below.  There are four
built-in monospaced fonts, available in the global variables
\&\fBgdGiantFont\fR, \fBgdLargeFont\fR, \fBgdMediumBoldFont\fR, \fBgdSmallFont\fR
and \fBgdTinyFont\fR.
.PP
In addition, you can use the \fBload()\fR method to load GD-formatted bitmap
font files at runtime. You can create these bitmap files from X11
BDF-format files using the bdf2gd.pl script, which should have been
installed with \s-1GD\s0 (see the bdf_scripts directory if it wasn't).  The
format happens to be identical to the old-style \s-1MSDOS\s0 bitmap \*(L".fnt\*(R"
files, so you can use one of those directly if you happen to have one.
.PP
For writing proportional scalable fonts, \s-1GD\s0 offers the \fBstringFT()\fR
method, which allows you to load and render any TrueType font on your
system.
.IP "\fB\f(CB$image\fB\->string($font,$x,$y,$string,$color)\fR" 4
.IX Item "$image->string($font,$x,$y,$string,$color)"
This method draws a string starting at position (x,y) in the specified
font and color.  Your choices of fonts are gdSmallFont, gdMediumBoldFont,
gdTinyFont, gdLargeFont and gdGiantFont.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage\->string(gdSmallFont,2,10,"Peachy Keen",$peach);
.Ve
.IP "\fB\f(CB$image\fB\->stringUp($font,$x,$y,$string,$color)\fR" 4
.IX Item "$image->stringUp($font,$x,$y,$string,$color)"
Just like the previous call, but draws the text rotated
counterclockwise 90 degrees.
.IP "\fB\f(CB$image\fB\->char($font,$x,$y,$char,$color)\fR" 4
.IX Item "$image->char($font,$x,$y,$char,$color)"
.PD 0
.IP "\fB\f(CB$image\fB\->charUp($font,$x,$y,$char,$color)\fR" 4
.IX Item "$image->charUp($font,$x,$y,$char,$color)"
.PD
These methods draw single characters at position (x,y) in the
specified font and color.  They're carry-overs from the C interface,
where there is a distinction between characters and strings.  Perl is
insensible to such subtle distinctions.
.ie n .IP "$font = \fBGD::Font\->load($fontfilepath)\fR" 4
.el .IP "\f(CW$font\fR = \fBGD::Font\->load($fontfilepath)\fR" 4
.IX Item "$font = GD::Font->load($fontfilepath)"
This method dynamically loads a font file, returning a font that you
can use in subsequent calls to drawing methods.  For example:
.Sp
.Vb 2
\&   my $courier = GD::Font\->load(\*(Aq./courierR12.fnt\*(Aq) or die "Can\*(Aqt load font";
\&   $image\->string($courier,2,10,"Peachy Keen",$peach);
.Ve
.Sp
Font files must be in \s-1GD\s0 binary format, as described above.
.IP "\fB\f(CB@bounds\fB = \f(CB$image\fB\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)\fR" 4
.IX Item "@bounds = $image->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)"
.PD 0
.IP "\fB\f(CB@bounds\fB = GD::Image\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)\fR" 4
.IX Item "@bounds = GD::Image->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)"
.IP "\fB\f(CB@bounds\fB = \f(CB$image\fB\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string,\e%options)\fR" 4
.IX Item "@bounds = $image->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string,%options)"
.PD
This method uses TrueType to draw a scaled, antialiased string using
the TrueType vector font of your choice.  It requires that libgd to
have been compiled with TrueType support, and for the appropriate
TrueType font to be installed on your system.
.Sp
The arguments are as follows:
.Sp
.Vb 6
\&  fgcolor    Color index to draw the string in
\&  fontname   A path to the TrueType (.ttf) font file or a font pattern.
\&  ptsize     The desired point size (may be fractional)
\&  angle      The rotation angle, in radians (positive values rotate counter clockwise)
\&  x,y        X and Y coordinates to start drawing the string
\&  string     The string itself
.Ve
.Sp
If successful, the method returns an eight-element list giving the
boundaries of the rendered string:
.Sp
.Vb 4
\& @bounds[0,1]  Lower left corner (x,y)
\& @bounds[2,3]  Lower right corner (x,y)
\& @bounds[4,5]  Upper right corner (x,y)
\& @bounds[6,7]  Upper left corner (x,y)
.Ve
.Sp
In case of an error (such as the font not being available, or \s-1FT\s0
support not being available), the method returns an empty list and
sets $@ to the error message.
.Sp
The \fBfontname\fR argument is the name of the font, which can be a full
pathname to a \fI.ttf\fR file, or if not the paths in \f(CW$ENV{GDFONTPATH}\fR
will be searched or if empty the libgd compiled \s-1DEFAULT_FONTPATH.\s0
The TrueType extensions .ttf, .pfa, .pfb or .dfont can be omitted.
.Sp
The string may contain \s-1UTF\-8\s0 sequences like: \*(L"&#192;\*(R"
.Sp
You may also call this method from the GD::Image class name, in which
case it doesn't do any actual drawing, but returns the bounding box
using an inexpensive operation.  You can use this to perform layout
operations prior to drawing.
.Sp
Using a negative color index will disable antialiasing, as described
in the libgd manual page at
<http://www.boutell.com/gd/manual2.0.9.html#gdImageStringFT>.
.Sp
An optional 8th argument allows you to pass a hashref of options to
\&\fBstringFT()\fR.  Several hashkeys are recognized: \fBlinespacing\fR,
\&\fBcharmap\fR, \fBresolution\fR, and \fBkerning\fR.
.Sp
The value of \fBlinespacing\fR is supposed to be a multiple of the
character height, so setting linespacing to 2.0 will result in
double-spaced lines of text.  However the current version of libgd
(2.0.12) does not do this.  Instead the linespacing seems to be double
what is provided in this argument.  So use a spacing of 0.5 to get
separation of exactly one line of text.  In practice, a spacing of 0.6
seems to give nice results.  Another thing to watch out for is that
successive lines of text should be separated by the \*(L"\er\en\*(R" characters,
not just \*(L"\en\*(R".
.Sp
The value of \fBcharmap\fR is one of \*(L"Unicode\*(R", \*(L"Shift_JIS\*(R" and \*(L"Big5\*(R".
The interaction between Perl, Unicode and libgd is not clear to me,
and you should experiment a bit if you want to use this feature.
.Sp
The value of \fBresolution\fR is the vertical and horizontal resolution,
in \s-1DPI,\s0 in the format \*(L"hdpi,vdpi\*(R".  If present, the resolution will be
passed to the Freetype rendering engine as a hint to improve the
appearance of the rendered font.
.Sp
The value of \fBkerning\fR is a flag.  Set it to false to turn off the
default kerning of text.
.Sp
Example:
.Sp
.Vb 5
\& $gd\->stringFT($black,\*(Aq/c/windows/Fonts/pala.ttf\*(Aq,40,0,20,90,
\&              "hi there\er\enbye now",
\&              {linespacing=>0.6,
\&               charmap  => \*(AqUnicode\*(Aq,
\&              });
.Ve
.Sp
If \s-1GD\s0 was compiled with fontconfig support, and the fontconfig library
is available on your system, then you can use a font name pattern
instead of a path.  Patterns are described in fontconfig and will
look something like this \*(L"Times:italic\*(R".  For backward
compatibility, this feature is disabled by default.  You must enable
it by calling \fBuseFontConfig\fR\|(1) prior to the \fBstringFT()\fR call.
.Sp
.Vb 1
\&   $image\->useFontConfig(1);
.Ve
.Sp
For backward compatibility with older versions of the FreeType
library, the alias \fBstringTTF()\fR is also recognized.
.IP "\fB\f(CB$hasfontconfig\fB = \f(CB$image\fB\->useFontConfig($flag)\fR" 4
.IX Item "$hasfontconfig = $image->useFontConfig($flag)"
Call \fBuseFontConfig()\fR with a value of 1 in order to enable support for
fontconfig font patterns (see stringFT).  Regardless of the value of
\&\f(CW$flag\fR, this method will return a true value if the fontconfig library
is present, or false otherwise.
.Sp
This method can also be called as a class method of GD::Image;
.IP "\fB\f(CB$result\fB = \f(CB$image\fB\->stringFTCircle($cx,$cy,$radius,$textRadius,$fillPortion,$font,$points,$top,$bottom,$fgcolor)\fR" 4
.IX Item "$result = $image->stringFTCircle($cx,$cy,$radius,$textRadius,$fillPortion,$font,$points,$top,$bottom,$fgcolor)"
This draws text in a circle. Currently (libgd 2.0.33) this function
does not work for me, but the interface is provided for completeness.
The call signature is somewhat complex.  Here is an excerpt from the
libgd manual page:
.Sp
Draws the text strings specified by top and bottom on the image, curved along
the edge of a circle of radius radius, with its center at cx and
cy. top is written clockwise along the top; bottom is written
counterclockwise along the bottom. textRadius determines the \*(L"height\*(R"
of each character; if textRadius is 1/2 of radius, characters extend
halfway from the edge to the center. fillPortion varies from 0 to 1.0,
with useful values from about 0.4 to 0.9, and determines how much of
the 180 degrees of arc assigned to each section of text is actually
occupied by text; 0.9 looks better than 1.0 which is rather
crowded. font is a freetype font; see gdImageStringFT. points is
passed to the freetype engine and has an effect on hinting; although
the size of the text is determined by radius, textRadius, and
fillPortion, you should pass a point size that \*(L"hints\*(R" appropriately
\&\*(-- if you know the text will be large, pass a large point size such as
24.0 to get the best results. fgcolor can be any color, and may have
an alpha component, do blending, etc.
.Sp
Returns a true value on success.
.SS "Alpha channels"
.IX Subsection "Alpha channels"
The alpha channel methods allow you to control the way drawings are
processed according to the alpha channel. When true color is turned
on, colors are encoded as four bytes, in which the last three bytes
are the \s-1RGB\s0 color values, and the first byte is the alpha channel.
Therefore the hexadecimal representation of a non transparent \s-1RGB\s0
color will be: C=0x00(rr)(bb)(bb)
.PP
When alpha blending is turned on, you can use the first byte of the
color to control the transparency, meaning that a rectangle painted
with color 0x00(rr)(bb)(bb) will be opaque, and another one painted
with 0x7f(rr)(gg)(bb) will be transparent. The Alpha value must be >=
0 and <= 0x7f.
.IP "\fB\f(CB$image\fB\->alphaBlending($integer)\fR" 4
.IX Item "$image->alphaBlending($integer)"
The \fBalphaBlending()\fR method allows for two different modes of drawing
on truecolor images. In blending mode, which is on by default (libgd
2.0.2 and above), the alpha channel component of the color supplied to
all drawing functions, such as \f(CW\*(C`setPixel\*(C'\fR, determines how much of the
underlying color should be allowed to shine through. As a result, \s-1GD\s0
automatically blends the existing color at that point with the drawing
color, and stores the result in the image. The resulting pixel is
opaque. In non-blending mode, the drawing color is copied literally
with its alpha channel information, replacing the destination
pixel. Blending mode is not available when drawing on palette images.
.Sp
Pass a value of 1 for blending mode, and 0 for non-blending mode.
.IP "\fB\f(CB$image\fB\->saveAlpha($saveAlpha)\fR" 4
.IX Item "$image->saveAlpha($saveAlpha)"
By default, \s-1GD\s0 (libgd 2.0.2 and above) does not attempt to save full
alpha channel information (as opposed to single-color transparency)
when saving \s-1PNG\s0 images. (\s-1PNG\s0 is currently the only output format
supported by gd which can accommodate alpha channel information.) This
saves space in the output file. If you wish to create an image with
alpha channel information for use with tools that support it, call
\&\f(CWsaveAlpha(1)\fR to turn on saving of such information, and call
\&\f(CWalphaBlending(0)\fR to turn off alpha blending within the library so
that alpha channel information is actually stored in the image rather
than being composited immediately at the time that drawing functions
are invoked.
.SS "Miscellaneous Image Methods"
.IX Subsection "Miscellaneous Image Methods"
These are various utility methods that are useful in some
circumstances.
.IP "\fB\f(CB$image\fB\->interlaced([$flag])\fR" 4
.IX Item "$image->interlaced([$flag])"
This method sets or queries the image's interlaced setting.  Interlace
produces a cool venetian blinds effect on certain viewers.  Provide a
true parameter to set the interlace attribute.  Provide undef to
disable it.  Call the method without parameters to find out the
current setting.
.IP "\fB($width,$height) = \f(CB$image\fB\->\fBgetBounds()\fB\fR" 4
.IX Item "($width,$height) = $image->getBounds()"
This method will return a two-member list containing the width and
height of the image.  You query but not change the size of the
image once it's created.
.IP "\fB\f(CB$width\fB = \f(CB$image\fB\->width\fR" 4
.IX Item "$width = $image->width"
.PD 0
.IP "\fB\f(CB$height\fB = \f(CB$image\fB\->height\fR" 4
.IX Item "$height = $image->height"
.PD
Return the width and height of the image, respectively.
.IP "\fB\f(CB$is_truecolor\fB = \f(CB$image\fB\->\fBisTrueColor()\fB\fR" 4
.IX Item "$is_truecolor = $image->isTrueColor()"
This method will return a Boolean representing whether the image
is true color or not.
.IP "\fB\f(CB$flag\fB = \f(CB$image1\fB\->compare($image2)\fR" 4
.IX Item "$flag = $image1->compare($image2)"
Compare two images and return a bitmap describing the differences
found, if any.  The return value must be logically \s-1AND\s0'ed with one or
more constants in order to determine the differences.  The following
constants are available:
.Sp
.Vb 9
\&  GD_CMP_IMAGE             The two images look different
\&  GD_CMP_NUM_COLORS        The two images have different numbers of colors
\&  GD_CMP_COLOR             The two images\*(Aq palettes differ
\&  GD_CMP_SIZE_X            The two images differ in the horizontal dimension
\&  GD_CMP_SIZE_Y            The two images differ in the vertical dimension
\&  GD_CMP_TRANSPARENT       The two images have different transparency
\&  GD_CMP_BACKGROUND        The two images have different background colors
\&  GD_CMP_INTERLACE         The two images differ in their interlace
\&  GD_CMP_TRUECOLOR         The two images are not both true color
.Ve
.Sp
The most important of these is \s-1GD_CMP_IMAGE,\s0 which will tell you
whether the two images will look different, ignoring differences in the
order of colors in the color palette and other invisible changes.  The
constants are not imported by default, but must be imported individually
or by importing the :cmp tag.  Example:
.Sp
.Vb 6
\&  use GD qw(:DEFAULT :cmp);
\&  # get $image1 from somewhere
\&  # get $image2 from somewhere
\&  if ($image1\->compare($image2) & GD_CMP_IMAGE) {
\&     warn "images differ!";
\&  }
.Ve
.IP "\fB\f(CB$image\fB\->clip($x1,$y1,$x2,$y2)\fR" 4
.IX Item "$image->clip($x1,$y1,$x2,$y2)"
.PD 0
.IP "\fB($x1,$y1,$x2,$y2) = \f(CB$image\fB\->clip\fR" 4
.IX Item "($x1,$y1,$x2,$y2) = $image->clip"
.PD
Set or get the clipping rectangle.  When the clipping rectangle is
set, all drawing will be clipped to occur within this rectangle.  The
clipping rectangle is initially set to be equal to the boundaries of
the whole image. Change it by calling \fBclip()\fR with the coordinates of
the new clipping rectangle.  Calling \fBclip()\fR without any arguments will
return the current clipping rectangle.
.IP "\fB\f(CB$flag\fB = \f(CB$image\fB\->boundsSafe($x,$y)\fR" 4
.IX Item "$flag = $image->boundsSafe($x,$y)"
The \fBboundsSafe()\fR method will return true if the point indicated by
($x,$y) is within the clipping rectangle, or false if it is not.  If
the clipping rectangle has not been set, then it will return true if
the point lies within the image boundaries.
.SS "Grouping Methods"
.IX Subsection "Grouping Methods"
\&\s-1GD\s0 does not support grouping of objects, but \s-1GD::SVG\s0 does. In that
subclass, the following methods declare new groups of graphical
objects:
.ie n .IP "$image\->startGroup([$id,\e%style])" 4
.el .IP "\f(CW$image\fR\->startGroup([$id,\e%style])" 4
.IX Item "$image->startGroup([$id,%style])"
.PD 0
.ie n .IP "$image\->\fBendGroup()\fR" 4
.el .IP "\f(CW$image\fR\->\fBendGroup()\fR" 4
.IX Item "$image->endGroup()"
.ie n .IP "$group = $image\->newGroup" 4
.el .IP "\f(CW$group\fR = \f(CW$image\fR\->newGroup" 4
.IX Item "$group = $image->newGroup"
.PD
See \s-1GD::SVG\s0 for information.
.SH "Polygons"
.IX Header "Polygons"
A few primitive polygon creation and manipulation methods are
provided.  They aren't part of the Gd library, but I thought they
might be handy to have around (they're borrowed from my qd.pl
Quickdraw library).  Also see GD::Polyline.
.IP "\fB\f(CB$poly\fB = GD::Polygon\->new\fR" 3
.IX Item "$poly = GD::Polygon->new"
Create an empty polygon with no vertices.
.Sp
.Vb 1
\&        $poly = GD::Polygon\->new;
.Ve
.IP "\fB\f(CB$poly\fB\->addPt($x,$y)\fR" 3
.IX Item "$poly->addPt($x,$y)"
Add point (x,y) to the polygon.
.Sp
.Vb 4
\&        $poly\->addPt(0,0);
\&        $poly\->addPt(0,50);
\&        $poly\->addPt(25,25);
\&        $myImage\->fillPoly($poly,$blue);
.Ve
.IP "\fB($x,$y) = \f(CB$poly\fB\->getPt($index)\fR" 3
.IX Item "($x,$y) = $poly->getPt($index)"
Retrieve the point at the specified vertex.
.Sp
.Vb 1
\&        ($x,$y) = $poly\->getPt(2);
.Ve
.IP "\fB\f(CB$poly\fB\->setPt($index,$x,$y)\fR" 3
.IX Item "$poly->setPt($index,$x,$y)"
Change the value of an already existing vertex.  It is an error to set
a vertex that isn't already defined.
.Sp
.Vb 1
\&        $poly\->setPt(2,100,100);
.Ve
.IP "\fB($x,$y) = \f(CB$poly\fB\->deletePt($index)\fR" 3
.IX Item "($x,$y) = $poly->deletePt($index)"
Delete the specified vertex, returning its value.
.Sp
.Vb 1
\&        ($x,$y) = $poly\->deletePt(1);
.Ve
.IP "\fB\f(CB$poly\fB\->\fBclear()\fB\fR" 3
.IX Item "$poly->clear()"
Delete all vertices, restoring the polygon to its initial empty state.
.IP "\fB\f(CB$poly\fB\->toPt($dx,$dy)\fR" 3
.IX Item "$poly->toPt($dx,$dy)"
Draw from current vertex to a new vertex, using relative (dx,dy)
coordinates.  If this is the first point, act like \fBaddPt()\fR.
.Sp
.Vb 4
\&        $poly\->addPt(0,0);
\&        $poly\->toPt(0,50);
\&        $poly\->toPt(25,\-25);
\&        $myImage\->fillPoly($poly,$blue);
.Ve
.IP "\fB\f(CB$vertex_count\fB = \f(CB$poly\fB\->length\fR" 3
.IX Item "$vertex_count = $poly->length"
Return the number of vertices in the polygon.
.Sp
.Vb 1
\&        $points = $poly\->length;
.Ve
.IP "\fB\f(CB@vertices\fB = \f(CB$poly\fB\->vertices\fR" 3
.IX Item "@vertices = $poly->vertices"
Return a list of all the vertices in the polygon object.  Each member
of the list is a reference to an (x,y) array.
.Sp
.Vb 4
\&        @vertices = $poly\->vertices;
\&        foreach $v (@vertices)
\&           print join(",",@$v),"\en";
\&        }
.Ve
.IP "\fB\f(CB@rect\fB = \f(CB$poly\fB\->bounds\fR" 3
.IX Item "@rect = $poly->bounds"
Return the smallest rectangle that completely encloses the polygon.
The return value is an array containing the (left,top,right,bottom) of
the rectangle.
.Sp
.Vb 1
\&        ($left,$top,$right,$bottom) = $poly\->bounds;
.Ve
.IP "\fB\f(CB$poly\fB\->offset($dx,$dy)\fR" 3
.IX Item "$poly->offset($dx,$dy)"
Offset all the vertices of the polygon by the specified horizontal
(dh) and vertical (dy) amounts.  Positive numbers move the polygon
down and to the right.
.Sp
.Vb 1
\&        $poly\->offset(10,30);
.Ve
.IP "\fB\f(CB$poly\fB\->map($srcL,$srcT,$srcR,$srcB,$destL,$dstT,$dstR,$dstB)\fR" 3
.IX Item "$poly->map($srcL,$srcT,$srcR,$srcB,$destL,$dstT,$dstR,$dstB)"
Map the polygon from a source rectangle to an equivalent position in a
destination rectangle, moving it and resizing it as necessary.  See
polys.pl for an example of how this works.  Both the source and
destination rectangles are given in (left,top,right,bottom)
coordinates.  For convenience, you can use the polygon's own bounding
box as the source rectangle.
.Sp
.Vb 2
\&        # Make the polygon really tall
\&        $poly\->map($poly\->bounds,0,0,50,200);
.Ve
.IP "\fB\f(CB$poly\fB\->scale($sx,$sy, [$tx,$ty])\fR" 3
.IX Item "$poly->scale($sx,$sy, [$tx,$ty])"
Scale each vertex of the polygon by the X and Y factors indicated by
sx and sy.  For example scale(2,2) will make the polygon twice as
large.  For best results, move the center of the polygon to position
(0,0) before you scale, then move it back to its previous position.
Accepts an optional offset vector.
.IP "\fB\f(CB$poly\fB\->transform($sx,$rx,$ry,$sy, \f(CB$tx\fB,$ty)\fR" 3
.IX Item "$poly->transform($sx,$rx,$ry,$sy, $tx,$ty)"
Run each vertex of the polygon through a 2D affine transformation
matrix, where sx and sy are the X and Y scaling factors, rx and ry are
the X and Y rotation factors, and tx and ty are X and Y offsets.  See
the Adobe PostScript Reference, page 154 for a full explanation, or
experiment.
.Sp
libgd:
.Sp
.Vb 8
\&    The transformation matrix is created using 6 numbers:
\&    matrix[0] == xx
\&    matrix[1] == yx
\&    matrix[2] == xy
\&    matrix[3] == xy (probably meaning yy here)
\&    matrix[4] == x0
\&    matrix[5] == y0
\&    where the transformation of a given point (x,y) is given by:
\&
\&    x_new = xx * x + xy * y + x0;
\&    y_new = yx * x + yy * y + y0;
.Ve
.SS "GD::Polyline"
.IX Subsection "GD::Polyline"
Please see GD::Polyline for information on creating open polygons
and splines.
.SH "Font Utilities"
.IX Header "Font Utilities"
The libgd library (used by the Perl \s-1GD\s0 library) has built-in support
for about half a dozen fonts, which were converted from public-domain
X Windows fonts.  For more fonts, compile libgd with TrueType support
and use the \fBstringFT()\fR call.
.PP
If you wish to add more built-in fonts, the directory bdf_scripts
contains two contributed utilities that may help you convert X\-Windows
BDF-format fonts into the format that libgd uses internally.  However
these scripts were written for earlier versions of \s-1GD\s0 which included
its own mini-gd library.  These scripts will have to be adapted for
use with libgd, and the libgd library itself will have to be
recompiled and linked!  Please do not contact me for help with these
scripts: they are unsupported.
.PP
Each of these fonts is available both as an imported global
(e.g. \fBgdSmallFont\fR) and as a package method
(e.g. \fBGD::Font\->Small\fR).
.IP "\fBgdSmallFont\fR" 5
.IX Item "gdSmallFont"
.PD 0
.IP "\fBGD::Font\->Small\fR" 5
.IX Item "GD::Font->Small"
.PD
This is the basic small font, \*(L"borrowed\*(R" from a well known public
domain 6x12 font.
.IP "\fBgdLargeFont\fR" 5
.IX Item "gdLargeFont"
.PD 0
.IP "\fBGD::Font\->Large\fR" 5
.IX Item "GD::Font->Large"
.PD
This is the basic large font, \*(L"borrowed\*(R" from a well known public
domain 8x16 font.
.IP "\fBgdMediumBoldFont\fR" 5
.IX Item "gdMediumBoldFont"
.PD 0
.IP "\fBGD::Font\->MediumBold\fR" 5
.IX Item "GD::Font->MediumBold"
.PD
This is a bold font intermediate in size between the small and large
fonts, borrowed from a public domain 7x13 font;
.IP "\fBgdTinyFont\fR" 5
.IX Item "gdTinyFont"
.PD 0
.IP "\fBGD::Font\->Tiny\fR" 5
.IX Item "GD::Font->Tiny"
.PD
This is a tiny, almost unreadable font, 5x8 pixels wide.
.IP "\fBgdGiantFont\fR" 5
.IX Item "gdGiantFont"
.PD 0
.IP "\fBGD::Font\->Giant\fR" 5
.IX Item "GD::Font->Giant"
.PD
This is a 9x15 bold font converted by Jan Pazdziora from a sans serif
X11 font.
.IP "\fB\f(CB$font\fB\->nchars\fR" 5
.IX Item "$font->nchars"
This returns the number of characters in the font.
.Sp
.Vb 1
\&        print "The large font contains ",gdLargeFont\->nchars," characters\en";
.Ve
.IP "\fB\f(CB$font\fB\->offset\fR" 5
.IX Item "$font->offset"
This returns the \s-1ASCII\s0 value of the first character in the font
.IP "\fB\f(CB$width\fB = \f(CB$font\fB\->width\fR" 5
.IX Item "$width = $font->width"
.PD 0
.IP "\fB\f(CB$height\fB = \f(CB$font\fB\->height\fR" 5
.IX Item "$height = $font->height"
.ie n .IP """height""" 5
.el .IP "\f(CWheight\fR" 5
.IX Item "height"
.PD
These return the width and height of the font.
.Sp
.Vb 1
\&  ($w,$h) = (gdLargeFont\->width,gdLargeFont\->height);
.Ve
.SH "Helper Functions"
.IX Header "Helper Functions"
.IP "\s-1GD::LIBGD_VERSION\s0" 4
.IX Item "GD::LIBGD_VERSION"
Returns a number of the libgd \s-1VERSION,\s0 like 2.0204, 2.0033 or 2.01.
.IP "\s-1GD::VERSION_STRING\s0" 4
.IX Item "GD::VERSION_STRING"
Returns the string of the libgd \s-1VERSION,\s0 like \*(L"2.2.4\*(R".
.IP "GD::constant" 4
.IX Item "GD::constant"
.SH "Obtaining the C\-language version of gd"
.IX Header "Obtaining the C-language version of gd"
libgd, the C\-language version of gd, can be obtained at \s-1URL\s0
http://libgd.org/  Directions for installing and using it
can be found at that site.  Please do not contact me for help with
libgd.
.SH "AUTHOR"
.IX Header "AUTHOR"
The \s-1GD\s0.pm interface is copyright 1995\-2010, Lincoln D. Stein. This
package and its accompanying libraries is free software; you can
redistribute it and/or modify it under the terms of the \s-1GPL\s0 (either
version 1, or at your option, any later version) or the Artistic
License 2.0.  Refer to \s-1LICENSE\s0 for the full license text.
package for details.
.PP
The latest versions of \s-1GD\s0.pm are available at
.PP
.Vb 1
\&  https://github.com/lstein/Perl\-GD
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
GD::Polyline,
\&\s-1GD::SVG\s0,
GD::Simple,
Image::Magick
