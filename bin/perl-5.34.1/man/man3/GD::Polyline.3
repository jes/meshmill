.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "GD::Polyline 3"
.TH GD::Polyline 3 "2022-01-26" "perl v5.34.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GD::Polyline \- Polyline object and Polygon utilities (including splines) for use with GD
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use GD;
\&        use GD::Polyline;
\&
\&        # create an image
\&        $image = GD::Image\->new (500,300);
\&        $white  = $image\->colorAllocate(255,255,255);
\&        $black  = $image\->colorAllocate(  0,  0,  0);
\&        $red    = $image\->colorAllocate(255,  0,  0);
\&
\&        # create a new polyline
\&        $polyline = GD::Polyline\->new;
\&
\&        # add some points
\&        $polyline\->addPt(  0,  0);
\&        $polyline\->addPt(  0,100);
\&        $polyline\->addPt( 50,125);
\&        $polyline\->addPt(100,  0);
\&
\&        # polylines can use polygon methods (and vice versa)
\&        $polyline\->offset(200,100);
\&
\&        # rotate 60 degrees, about the centroid
\&        $polyline\->rotate(3.14159/3, $polyline\->centroid());
\&
\&        # scale about the centroid
\&        $polyline\->scale(1.5, 2, $polyline\->centroid());
\&
\&        # draw the polyline
\&        $image\->polydraw($polyline,$black);
\&
\&        # create a spline, which is also a polyine
\&        $spline = $polyline\->addControlPoints\->toSpline;
\&        $image\->polydraw($spline,$red);
\&
\&        # output the png
\&        binmode STDOUT;
\&        print $image\->png;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBPolyline.pm\fR extends the \s-1GD\s0 module by allowing you to create polylines.  Think
of a polyline as \*(L"an open polygon\*(R", that is, the last vertex is not connected
to the first vertex (unless you expressly add the same value as both points).
.PP
For the remainder of this doc, \*(L"polyline\*(R" will refer to a GD::Polyline,
\&\*(L"polygon\*(R" will refer to a GD::Polygon that is not a polyline, and
\&\*(L"polything\*(R" and \*(L"$poly\*(R" may be either.
.PP
The big feature added to \s-1GD\s0 by this module is the means
to create splines, which are approximations to curves.
.SH "The Polyline Object"
.IX Header "The Polyline Object"
GD::Polyline defines the following class:
.ie n .IP """GD::Polyline""" 5
.el .IP "\f(CWGD::Polyline\fR" 5
.IX Item "GD::Polyline"
A polyline object, used for storing lists of vertices prior to
rendering a polyline into an image.
.ie n .IP """new""" 5
.el .IP "\f(CWnew\fR" 5
.IX Item "new"
\&\f(CW\*(C`GD::Polyline\->new\*(C'\fR \fIclass method\fR
.Sp
Create an empty polyline with no vertices.
.Sp
.Vb 1
\&        $polyline = GD::Polyline\->new;
\&
\&        $polyline\->addPt(  0,  0);
\&        $polyline\->addPt(  0,100);
\&        $polyline\->addPt( 50,100);
\&        $polyline\->addPt(100,  0);
\&
\&        $image\->polydraw($polyline,$black);
.Ve
.Sp
In fact GD::Polyline is a subclass of GD::Polygon,
so all polygon methods (such as \fBoffset\fR and \fBtransform\fR)
may be used on polylines.
Some new methods have thus been added to GD::Polygon (such as \fBrotate\fR)
and a few updated/modified/enhanced (such as \fBscale\fR) \fIin this module\fR.
See section \*(L"New or Updated GD::Polygon Methods\*(R" for more info.
.PP
Note that this module is very \*(L"young\*(R" and should be
considered subject to change in future releases, and/or
possibly folded in to the existing polygon object and/or \s-1GD\s0 module.
.SH "Updated Polygon Methods"
.IX Header "Updated Polygon Methods"
The following methods (defined in \s-1GD\s0.pm) are \s-1OVERRIDDEN\s0 if you use this module.
.PP
All effort has been made to provide 100% backward compatibility, but if you
can confirm that has not been achieved, please consider that a bug and let the
the author of Polyline.pm know.
.ie n .IP """scale""" 5
.el .IP "\f(CWscale\fR" 5
.IX Item "scale"
\&\f(CW\*(C`$poly\->scale($sx, $sy, $cx, $cy)\*(C'\fR \fIobject method \*(-- \s-1UPDATE\s0 to GD::Polygon::scale\fR
.Sp
Scale a polything in along x\-axis by \f(CW$sx\fR and along the y\-axis by \f(CW$sy\fR,
about centery point ($cx, \f(CW$cy\fR).
.Sp
Center point ($cx, \f(CW$cy\fR) is optional \*(-- if these are omitted, the function
will scale about the origin.
.Sp
To flip a polything, use a scale factor of \-1.  For example, to
flip the polything top to bottom about line y = 100, use:
.Sp
.Vb 1
\&        $poly\->scale(1, \-1, 0, 100);
.Ve
.SH "New Polygon Methods"
.IX Header "New Polygon Methods"
The following methods are added to GD::Polygon, and thus can be used
by polygons and polylines.
.PP
Don't forget: a polyline is a GD::Polygon, so GD::Polygon methods
like \fBoffset()\fR can be used, and they can be used in
GD::Image methods like \fBfilledPolygon()\fR.
.ie n .IP """rotate""" 5
.el .IP "\f(CWrotate\fR" 5
.IX Item "rotate"
\&\f(CW\*(C`$poly\->rotate($angle, $cx, $cy)\*(C'\fR \fIobject method\fR
.Sp
Rotate a polything through \f(CW$angle\fR (clockwise, in radians) about center point ($cx, \f(CW$cy\fR).
.Sp
Center point ($cx, \f(CW$cy\fR) is optional \*(-- if these are omitted, the function
will rotate about the origin
.Sp
In this function and other angle-oriented functions in GD::Polyline,
positive \f(CW$angle\fR corresponds to clockwise rotation.  This is opposite
of the usual Cartesian sense, but that is because the raster is opposite
of the usual Cartesian sense in that the y\-axis goes \*(L"down\*(R".
.ie n .IP """centroid""" 5
.el .IP "\f(CWcentroid\fR" 5
.IX Item "centroid"
\&\f(CW\*(C`($cx, $cy) = $poly\->centroid($scale)\*(C'\fR \fIobject method\fR
.Sp
Calculate and return ($cx, \f(CW$cy\fR), the centroid of the vertices of the polything.
For example, to rotate something 180 degrees about it's centroid:
.Sp
.Vb 1
\&        $poly\->rotate(3.14159, $poly\->centroid());
.Ve
.Sp
\&\f(CW$scale\fR is optional; if supplied, \f(CW$cx\fR and \f(CW$cy\fR are multiplied by \f(CW$scale\fR
before returning.  The main use of this is to shift an polything to the
origin like this:
.Sp
.Vb 1
\&        $poly\->offset($poly\->centroid(\-1));
.Ve
.ie n .IP """segLength""" 5
.el .IP "\f(CWsegLength\fR" 5
.IX Item "segLength"
\&\f(CW\*(C`@segLengths = $poly\->segLength()\*(C'\fR \fIobject method\fR
.Sp
In array context, returns an array the lengths of the segments in the polything.
Segment n is the segment from vertex n to vertex n+1.
Polygons have as many segments as vertices; polylines have one fewer.
.Sp
In a scalar context, returns the sum of the array that would have been returned
in the array context.
.ie n .IP """segAngle""" 5
.el .IP "\f(CWsegAngle\fR" 5
.IX Item "segAngle"
\&\f(CW\*(C`@segAngles = $poly\->segAngle()\*(C'\fR \fIobject method\fR
.Sp
Returns an array the angles of each segment from the x\-axis.
Segment n is the segment from vertex n to vertex n+1.
Polygons have as many segments as vertices; polylines have one fewer.
.Sp
Returned angles will be on the interval 0 <= \f(CW$angle\fR < 2 * pi and
angles increase in a clockwise direction.
.ie n .IP """vertexAngle""" 5
.el .IP "\f(CWvertexAngle\fR" 5
.IX Item "vertexAngle"
\&\f(CW\*(C`@vertexAngles = $poly\->vertexAngle()\*(C'\fR \fIobject method\fR
.Sp
Returns an array of the angles between the segment into and out of each vertex.
For polylines, the vertex angle at vertex 0 and the last vertex are not defined;
however \f(CW$vertexAngle\fR[0] will be undef so that \f(CW$vertexAngle\fR[1] will correspond to
vertex 1.
.Sp
Returned angles will be on the interval 0 <= \f(CW$angle\fR < 2 * pi and
angles increase in a clockwise direction.
.Sp
Note that this calculation does not attempt to figure out the \*(L"interior\*(R" angle
with respect to \*(L"inside\*(R" or \*(L"outside\*(R" the polygon, but rather,
just the angle between the adjacent segments
in a clockwise sense.  Thus a polygon with all right angles will have vertex
angles of either pi/2 or 3*pi/2, depending on the way the polygon was \*(L"wound\*(R".
.ie n .IP """toSpline""" 5
.el .IP "\f(CWtoSpline\fR" 5
.IX Item "toSpline"
\&\f(CW\*(C`$poly\->toSpline()\*(C'\fR \fIobject method & factory method\fR
.Sp
Create a new polything which is a reasonably smooth curve
using cubic spline algorithms, often referred to as Bezier
curves.  The \*(L"source\*(R" polything is called the \*(L"control polything\*(R".
If it is a polyline, the control polyline must
have 4, 7, 10, or some number of vertices of equal to 3n+1.
If it is a polygon, the control polygon must
have 3, 6, 9, or some number of vertices of equal to 3n.
.Sp
.Vb 2
\&        $spline = $poly\->toSpline();
\&        $image\->polydraw($spline,$red);
.Ve
.Sp
In brief, groups of four points from the control polyline
are considered \*(L"control
points\*(R" for a given portion of the spline: the first and
fourth are \*(L"anchor points\*(R", and the spline passes through
them; the second and third are \*(L"director points\*(R".  The
spline does not pass through director points, however the
spline is tangent to the line segment from anchor point to
adjacent director point.
.Sp
The next portion of the spline reuses the previous portion's
last anchor point.  The spline will have a cusp
(non-continuous slope) at an anchor point, unless the anchor
points and its adjacent director point are colinear.
.Sp
In the current implementation, \fBtoSpline()\fR return a fixed
number of segments in the returned polyline per set-of-four
control points.  In the future, this and other parameters of
the algorithm may be configurable.
.ie n .IP """addControlPoints""" 5
.el .IP "\f(CWaddControlPoints\fR" 5
.IX Item "addControlPoints"
\&\f(CW\*(C`$polyline\->addControlPoints()\*(C'\fR \fIobject method & factory method\fR
.Sp
So you say: \*(L"\s-1OK.\s0  Splines sound cool.  But how can I
get my anchor points and its adjacent director point to be
colinear so that I have a nice smooth curves from my
polyline?\*(R"  Relax!  For The Lazy: \fBaddControlPoints()\fR to the
rescue.
.Sp
\&\fBaddControlPoints()\fR returns a polyline that can serve
as the control polyline for \fBtoSpline()\fR, which returns
another polyline which is the spline.  Is your head spinning
yet?  Think of it this way:
.RS 5
.IP "+" 5
If you have a polyline, and you have already put your
control points where you want them, call \fBtoSpline()\fR directly.
Remember, only every third vertex will be \*(L"on\*(R" the spline.
.Sp
You get something that looks like the spline \*(L"inscribed\*(R"
inside the control polyline.
.IP "+" 5
If you have a polyline, and you want all of its vertices on
the resulting spline, call \fBaddControlPoints()\fR and then
\&\fBtoSpline()\fR:
.Sp
.Vb 3
\&        $control = $polyline\->addControlPoints();
\&        $spline  = $control\->toSpline();
\&        $image\->polyline($spline,$red);
.Ve
.Sp
You get something that looks like the control polyline \*(L"inscribed\*(R"
inside the spline.
.RE
.RS 5
.Sp
Adding \*(L"good\*(R" control points is subjective; this particular
algorithm reveals its author's tastes.
In the future, you may be able to alter the taste slightly
via parameters to the algorithm.  For The Hubristic: please
build a better one!
.Sp
And for The Impatient: note that \fBaddControlPoints()\fR returns a
polyline, so you can pile up the call like this,
if you'd like:
.Sp
.Vb 1
\&        $image\->polyline($polyline\->addControlPoints()\->toSpline(),$mauve);
.Ve
.RE
.SH "New GD::Image Methods"
.IX Header "New GD::Image Methods"
.ie n .IP """polyline""" 5
.el .IP "\f(CWpolyline\fR" 5
.IX Item "polyline"
\&\f(CW\*(C`$image\->polyline(polyline,color)\*(C'\fR \fIobject method\fR
.Sp
.Vb 1
\&        $image\->polyline($polyline,$black)
.Ve
.Sp
This draws a polyline with the specified color.
Both real color indexes and the special
colors gdBrushed, gdStyled and gdStyledBrushed can be specified.
.Sp
Neither the \fBpolyline()\fR method or the \fBpolygon()\fR method are very
picky: you can call either method with either a GD::Polygon or a GD::Polyline.
The \fImethod\fR determines if the shape is \*(L"closed\*(R" or \*(L"open\*(R" as drawn, \fInot\fR
the object type.
.ie n .IP """polydraw""" 5
.el .IP "\f(CWpolydraw\fR" 5
.IX Item "polydraw"
\&\f(CW\*(C`$image\->polydraw(polything,color)\*(C'\fR \fIobject method\fR
.Sp
.Vb 1
\&        $image\->polydraw($poly,$black)
.Ve
.Sp
This method draws the polything as expected (polygons are closed,
polylines are open) by simply checking the object type and calling
either \f(CW$image\fR\->\fBpolygon()\fR or \f(CW$image\fR\->\fBpolyline()\fR.
.SH "Examples"
.IX Header "Examples"
Please see file \*(L"polyline\-examples.pl\*(R" that is included with the distribution.
.SH "See Also"
.IX Header "See Also"
For more info on Bezier splines, see http://www.webreference.com/dlab/9902/bezier.html.
.SH "Future Features"
.IX Header "Future Features"
On the drawing board are additional features such as:
.PP
.Vb 1
\&        \- polygon winding algorithms (to determine if a point is "inside" or "outside" the polygon)
\&
\&        \- new polygon from bounding box
\&
\&        \- find bounding polygon (tightest fitting simple convex polygon for a given set of vertices)
\&
\&        \- addPts() method to add many points at once
\&
\&        \- clone() method for polygon
\&
\&        \- functions to interwork GD with SVG
.Ve
.PP
Please provide input on other possible features you'd like to see.
.SH "Author"
.IX Header "Author"
This module has been written by Daniel J. Harasty.
Please send questions, comments, complaints, and kudos to him
at harasty@cpan.org.
.PP
Thanks to Lincoln Stein for input and patience with me and this,
my first \s-1CPAN\s0 contribution.
.SH "Copyright Information"
.IX Header "Copyright Information"
The Polyline.pm module is copyright 2002, Daniel J. Harasty.  It is
distributed under the same terms as Perl itself.  See the \*(L"Artistic
License\*(R" in the Perl source code distribution for licensing terms.
.PP
The latest version of Polyline.pm is available at
your favorite \s-1CPAN\s0 repository and/or
along with \s-1GD\s0.pm by Lincoln D. Stein at http://stein.cshl.org/WWW/software/GD.
