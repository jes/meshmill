#!/usr/bin/perl

# pngcam
# https://github.com/jes/pngcam

package Pngcam::Render;

use strict;
use warnings;

import CAD::Format::STL;
use GD;

sub new {
    my ($pkg, %opts) = @_;

    my $self = bless \%opts, $pkg;

    $self->{triangles} = [];

    $self->{minx} = undef;
    $self->{maxx} = undef;
    $self->{miny} = undef;
    $self->{maxy} = undef;
    $self->{minz} = undef;
    $self->{maxz} = undef;

    my $stl = CAD::Format::STL->new->load($self->{stl_file});
    
    # TODO: what do we do if there is more than one part?

    for my $data ($stl->part->facets) {
        my ($normal, @verts) = @$data;
        for my $v (@verts) {
            my ($x, $y, $z) = @$v;
            $self->{minx} = $x if !defined $self->{minx} || $x < $self->{minx};
            $self->{maxx} = $x if !defined $self->{maxx} || $x > $self->{maxx};
            $self->{miny} = $y if !defined $self->{miny} || $y < $self->{miny};
            $self->{maxy} = $y if !defined $self->{maxy} || $y > $self->{maxy};
            $self->{minz} = $z if !defined $self->{minz} || $z < $self->{minz};
            $self->{maxz} = $z if !defined $self->{maxz} || $z > $self->{maxz};
        }
        push @{ $self->{triangles} }, \@verts;
    }

    $self->{mmwidth} = $self->{maxx} - $self->{minx};
    $self->{mmheight} = $self->{maxy} - $self->{miny};

    my $aspect_ratio = $self->{mmwidth} / $self->{mmheight};
    if (!defined $self->{width}) {
        $self->{width} = $self->{height} * $aspect_ratio;
    }
    if (!defined $self->{height}) {
        $self->{height} = $self->{width} / $aspect_ratio;
    }

    $self->{image} = GD::Image->new($self->{width} + $self->{border}*2, $self->{height} + $self->{border}*2, 1);

    # calculate pixels per mm
    $self->{x_px_mm} = $self->{width} / $self->{mmwidth};
    $self->{y_px_mm} = $self->{height} / $self->{mmheight};
    if ($self->{rgb}) {
        $self->{z_px_mm} = 16777215 / ($self->{maxz} - $self->{minz}); # not really "pixels" but meh
    } else {
        $self->{z_px_mm} = 255 / ($self->{maxz} - $self->{minz}); # not really "pixels" but meh
    }

    return $self;
}

sub run {
    my ($self) = @_;

    if (!$self->{quiet}) {
        my $mmz = $self->{maxz} - $self->{minz};
        my $border_x_mm = $self->{border} / $self->{x_px_mm};
        my $border_y_mm = $self->{border} / $self->{y_px_mm};
        print STDERR "$self->{width}x$self->{width} px depth map. $self->{mmwidth}x$self->{mmheight} mm work piece.\n";
        print STDERR "Work piece is $mmz mm tall in Z axis.\n";
        print STDERR "X border of $self->{border} px = $border_x_mm mm. Y border of $self->{border} px = $border_y_mm mm.\n";
        print STDERR "Output image is " . ($self->{width}+$self->{border}*2) . "x" . ($self->{height}+$self->{border}*2) . " px = " . ($self->{mmwidth}+$border_x_mm*2) . "x" . ($self->{mmheight} + $border_y_mm*2) . " mm.\n";
        print STDERR "X resolution is $self->{x_px_mm} px/mm. Y resolution is $self->{y_px_mm} px/mm.\n";
    }

    # clear to black
    my $black = $self->{image}->colorAllocate(0,0,0);
    $self->{image}->filledRectangle(0, 0, $self->{width}, $self->{height}, $black);

    # render each triangle
    # since we're drawing a heightmap, the image itself acts as the depth buffer
    my $ntriangles = @{ $self->{triangles} };
    my $done = 0;
    for my $t (@{ $self->{triangles} }) {
        my @vertices = @$t;
        $self->draw_triangle(map { $self->mm_to_px($_) } @vertices);

        $done++;
        my $pct = sprintf("%2d", 100 * $done / $ntriangles);
        print STDERR "   \rDrawing triangles: $pct%" if !$self->{quiet};
    }
    print STDERR "    \rDrawing triangles: done.\n" if !$self->{quiet};
}

sub save {
    my ($self, $file) = @_;
    return $self->{image}->_file($file);
}

sub mm_to_px {
    my ($self, $v) = @_;

    my ($x,$y,$z) = @$v;

    $y = $self->{border} + ($self->{maxy} - $y) * $self->{y_px_mm}; # note y axis is inverted

    if ($self->{bottom}) {
        # view from bottom (flip x and z)
        $x = $self->{border} + ($self->{maxx} - $x) * $self->{x_px_mm};
        $z = ($self->{maxz} - $z) * $self->{z_px_mm};
    } else {
        # view from top
        $x = $self->{border} + ($x - $self->{minx}) * $self->{x_px_mm};
        $z = ($z - $self->{minz}) * $self->{z_px_mm};
    }

    return [$x, $y, $z];
}

# give vertices in px
sub draw_triangle {
    my ($self, $v1, $v2, $v3) = @_;

    my %minx;
    my %maxx;

    my $miny;
    my $maxy;

    # 1. work out where the outline of the triangle is

    # this function will get called for every pixel that lies on the perimeter of the triangle
    my $perimeter_cb = sub {
        my ($x, $y, $z) = @_;

        # store the point at the minimum and maximum x coordinate observed on each y coordinate
        $minx{$y} = [$x, $y, $z] if !defined $minx{$y} || $x < $minx{$y}[0];
        $maxx{$y} = [$x, $y, $z] if !defined $maxx{$y} || $x > $maxx{$y}[0];

        $miny = $y if !defined $miny || $y < $miny;
        $maxy = $y if !defined $maxy || $y > $maxy;
    };

    $self->iterate_line($v1, $v2, $perimeter_cb);
    $self->iterate_line($v2, $v3, $perimeter_cb);
    $self->iterate_line($v3, $v1, $perimeter_cb);

    # 2. fill in scanlines
    for my $y ($miny .. $maxy) {
        my $startx = $minx{$y}[0];
        my $endx = $maxx{$y}[0];
        my $startz = $minx{$y}[2];
        my $endz = $maxx{$y}[2];
        my $zchange = $endz - $startz;
        my $xlength = $endx - $startx;
        for my $x ($startx .. $endx) {
            my $k = $xlength ? ($x - $startx) / $xlength : 1;
            my $z = $startz + $zchange * $k;
            $self->plot($x, $y, $z);
        }
    }
}

# plot Z at (X,Y) in the image if that is brighter than what is already there; if it is darker
# then do nothing
sub plot {
    my ($self, $x, $y, $z) = @_;

    my $col = $self->{image}->getPixel($x, $y);
    my ($r,$g,$b) = $self->{image}->rgb($col);

    my $h = $self->{rgb} ? 65536*$r+256*$g+$b : $r;

    return if $h > $z; # do nothing if existing brightness is brighter than what we're going to draw

    if ($self->{rgb}) {
        $r = int($z/65536);
        $g = int($z/256)%256;
        $b = $z%256;
    } else {
        $r = $z;
        $g = $z;
        $b = $z;
    }

    my $newcol = $self->{image}->colorAllocate($r, $g, $b);
    $self->{image}->setPixel($x, $y, $newcol);
}

# call the callback on every pixel on the line p1->p2 in 2d space (x/y); p1 and p2 are 3d
# points, and the 3rd dimension will be interpolated as well
sub iterate_line {
    my ($self, $p1, $p2, $cb) = @_;

    # visit the first point
    $cb->(map { int($_) } @$p1);

    my $dx = $p2->[0] - $p1->[0];
    my $dy = $p2->[1] - $p1->[1];
    my $dz = $p2->[2] - $p1->[2];

    my $length = sqrt($dx*$dx + $dy*$dy); # only 2d

    # if the line has 0 pixels length in 2d, only plot the 1st pixel, and avoid dividing by 0
    return if $length < 1;

    my $stepx = $dx / $length;
    my $stepy = $dy / $length;
    my $stepz = $dz / $length;

    my ($x,$y,$z) = @$p1;

    # visit each point on the line, stepping 1px at a time along a diagonal
    for (1..int($length)) {
        $x += $stepx;
        $y += $stepy;
        $z += $stepz;
        $cb->(int($x), int($y), int($z));
    }
}

1;
package CAD::Format::STL;
our $VERSION = v0.2.1;

use warnings;
use strict;
use Carp;

import CAD::Format::STL::part;

=head1 NAME

CAD::Format::STL - read/write 3D stereolithography files

=head1 SYNOPSIS

Reading:

  my $stl = CAD::Format::STL->new->load("foo.stl");
  # what about the part/multipart?
  my @facets = $stl->part->facets;

Writing:

  my $stl = CAD::Format::STL->new;
  my $part = $stl->add_part("my part");
  $part->add_facets(@faces);
  $stl->save("foo.stl");
  # or $stl->save(binary => "foo.stl");

Streaming read/write:

  my $reader = CAD::Format::STL->reader("foo.stl");
  my $writer = CAD::Format::STL->writer(binary => "bar.stl");
  while(my $part = $reader->next_part) {
    my $part_name = $part->name;
    $writer->start_solid($part_name);
    while(my @data = $part->facet) {
      my ($normal, @vertices) = @data;
      my @v1 = @{$vertices[0]};
      my @v2 = @{$vertices[0]};
      my @v3 = @{$vertices[0]};
      # that's just for illustration
      $writer->facet(\@v1, \@v2, \@v3);
      # note the omitted normal
    }
    $writer->end_solid;
  }

=begin design

The reader auto-detects whether it is binary (but assumes ascii when
seek can't go backwards.)

The reader and writer both take 1, 2, or {1,2}+2n arguments.

This package and/or the reader/writer are subclassable (though getting
$self->reader to instantiate a subclass implies that you have subclassed
$self.)

A cached_facet (or raw_facet) method is necessary to ensure uniform
tranformation of shared points (and optimize the computation.)  This
would return the normal and points as a list of scalars rather than
arrays, with a later call to unpack_point() or something.  The caller
needs to be able to handle the caching (or else there is a callback for
non-cached (or an override for unpack_point().)

Maybe $self->set_writer() and set_reader() immutable object methods?

=end design

=head1 ABOUT

This module provides object-oriented methods to read and write the STL
(Stereo Lithography) file format in both binary and ASCII forms.  The
STL format is a simple set of 3D triangles.

=cut

use Class::Accessor::Classy;
lo 'parts';
no  Class::Accessor::Classy;

=head1 Constructor

=head2 new

  my $stl = CAD::Format::STL->new;

=cut

sub new {
  my $package = shift;
  my $class = ref($package) || $package;
  my $self = {parts => []};
  bless($self, $class);
  return($self);
} # end subroutine new definition
########################################################################

=head2 add_part

Create a new part in the stl.

  my $part = $stl->add_part("name");

Optionally, add the faces directly:

  my $part = $stl->add_part("name", @faces);

=cut

sub add_part {
  my $self = shift;
  my ($name, @faces) = @_;

  my $part = CAD::Format::STL::part->new($name, @faces);
  push(@{$self->{parts}}, $part);
  return($part);
} # end subroutine add_part definition
########################################################################

=head2 part

Get the part at $index.  Negative indices are valid.

  my $part = $stl->part($index);

Throws an error if there is no such part.

=cut

sub part {
  my $self = shift;
  my ($index) = @_;

  @{$self->{parts}} or croak("file has no parts");

  $index ||= 0;
  exists($self->{parts}[$index]) or croak("no part $index");
  return($self->{parts}[$index]);
} # end subroutine part definition
########################################################################

=head1 I/O Methods

=head2 load

Load an STL file (auto-detects binary/ascii)

  $stl = $stl->load("filename.stl");

Optionally, explicitly declare binary mode:

  $stl = $stl->load(binary => "filename.stl");

The $self object is returned to allow e.g. chaining to C<new()>.

The filename may also be a filehandle.

=cut

sub load {
  my $self = shift;
  my ($file, @and) = @_;

  my $mode;
  if(@and) {
    (@and > 1) and croak('too many arguments to load()');
    $mode = $file;
    ($file) = @and;
  }

  # allow filehandle
  unless((ref($file) || '') eq 'GLOB') {
    open(my $fh, '<', $file) or
      die "cannot open '$file' for reading $!";
    $file = $fh;
  }

  # detection
  unless($mode) {
    unless(seek($file, 0,0)) {
      croak('must have explicit mode for non-seekable filehandle');
    }
    # now, detection...
    $mode = sub {
      my $fh = shift;
      seek($fh, 80, 0);
      my $count = eval {
        my $buf; read($fh, $buf, 4) or die;
        unpack('L', $buf);
      };
      $@ and return 'ascii'; # if we hit eof, it can't be binary
      $count or die "detection failed - no facets?";
      my $size = (stat($fh))[7];
      # calculate the expected file size
      my $expect =
        + 80 # header
        +  4 # count
        + $count * (
          + 4 # normal, pt,pt,pt (vectors)
          * 4 # bytes per value
          * 3 # values per vector
          + 2 # the trailing 'short'
        );
      return ($size == $expect) ? 'binary' : 'ascii';
    }->($file);
    seek($file, 0, 0) or die "cannot reset filehandle";
  }

  my $method = '_read_' . lc($mode);
  $self->can($method) or croak("invalid read mode '$mode'");

  $self->$method($file);
  return($self);
} # end subroutine load definition
########################################################################

=head2 _read_ascii

  $self->_read_ascii($filehandle);

=cut

sub _read_ascii {
  my $self = shift;
  my ($fh) = @_;

  my $getline = sub {
    while(my $line = <$fh>) {
      $line =~ s/\s*$//; # allow any eol
      length($line) or next;
      return($line);
    }
    return;
  };
  my $p_re = qr/([^ ]+)\s+([^ ]+)\s+([^ ]+)$/;

  my $part;
  while(my $line = $getline->()) {

    if($line =~ m/^\s*solid (.*)/) {
      $part = $self->add_part($1);
    }
    elsif($line =~ m/^\s*endsolid (.*)/) {
      my $name = $1;
      $part or die "invalid 'endsolid' entry with no current part";
      ($name eq $part->name) or
        die "end of part '$name' should have been '",
          $part->name, "'";
      $part = undef;
    }
    elsif($part) {
      my @n = ($line =~ m/^\s*facet\s+normal\s+$p_re/) or
        die "how did that happen? ($line)";
      #warn "got ", join('|', @n);
      my @facet = (\@n);

      my $next = $getline->();
      unless($next and ($next =~ m/^\s*outer\s+loop$/)) {
        die "facet doesn't start with 'outer loop' ($next)";
      }
      push(@facet, do {
        my @got;
        while(my $line = $getline->()) {
          ($line =~ m/^\s*endloop$/) and last;
          if($line =~ m/^\s*vertex\s+$p_re/) {
            push(@got, [$1, $2, $3]);
          }
        }
        @got;
      });
      (scalar(@facet) == 4) or
        die "need three vertices per facet (not $#facet)";
      my $end = $getline->();
      ($end and ($end =~ m/^\s*endfacet/)) or
        die "bad endfacet $line";
      $part->add_facets([@facet]);
    }
    else {
      die "what? ($line)";
    }
  }
  $part and die "part '", $part->name, "' was left open";
} # end subroutine _read_ascii definition
########################################################################

=head2 get_<something>

These functions are currently only used internally.

=over

=item get_triangle

=item get_ulong

=item get_float32

=item get_short

=back

=cut

sub get_triangle {
  my ($fh) = @_;

  my ($n, $x, $y, $z) = map({[map({get_float32($fh)} 1..3)]} 1..4);
  my $scrap = get_short($fh);
  return($n, $x, $y, $z);
}

sub get_ulong {
  my ($fh) = @_;

  my $buf;
  read($fh, $buf, 4) or warn "EOF?";
  return(unpack('L', $buf));
}

sub get_float32 {
  my ($fh) = @_;

  my $buf;
  read($fh, $buf, 4) or warn "EOF?";
  return(unpack('f', $buf));
}

sub get_short {
  my ($fh) = @_;

  my $buf;
  read($fh, $buf, 2) or warn "EOF?";
  return(unpack('S', $buf));
}

=head2 _read_binary

  $self->_read_binary($filehandle);

=cut

sub _read_binary {
  my $self = shift;
  my ($fh) = @_;

  $self->parts and die "binary STL files must have only one part";

  die "bigfloat" unless(length(pack("f", 1)) == 4);
  # TODO try to read part name from header (up to \0)
  my $name = 'a part';
  seek($fh, 80, 0);

  my $triangles = get_ulong($fh);
  my $part = $self->add_part($name);

  my $count = 0;
  while(1) {
    my @tr = get_triangle($fh);
    # TODO check that the unit normal is within a thousandth of a radian
    # (0.001 rad is ~0.06deg)
    $part->add_facets([@tr]);
    $count++;
    eof($fh) and last;
  }
  ($count == $triangles) or
    die "ERROR: got $count facets (expected $triangles)";
} # end subroutine _read_binary definition
########################################################################

=head2 save

  $stl->save("filename.stl");

  $stl->save(binary => "filename.stl");

=cut

sub save {
  my $self = shift;
  my ($file, @and) = @_;

  my $mode;
  if(@and) {
    (@and > 1) and croak('too many arguments to save()');
    $mode = $file;
    ($file) = @and;
  }

  # allow filehandle
  unless((ref($file) || '') eq 'GLOB') {
    open(my $fh, '>', $file) or
      die "cannot open '$file' for writing $!";
    $file = $fh;
  }

  $mode = 'ascii' unless($mode);

  my $method = '_write_' . lc($mode);
  $self->can($method) or croak("invalid write mode '$mode'");

  $self->$method($file);
} # end subroutine save definition
########################################################################

=head2 _write_binary

  $self->_write_binary($filehandle);

=cut

sub _write_binary {
  my $self = shift;
  my ($fh) = @_;

  my ($part, @and) = $self->parts;
  @and and die 'cannot write binary files with multiple parts';

  my $name = $part->name; # utf8 is ok
  print $fh $name, "\0" x (80 - do {use bytes; length($name)});
  my @facets = $part->facets;
  print $fh pack('L', scalar(@facets));
  foreach my $facet (@facets) {
    print $fh map({map({pack('f', $_)} @$_)} @$facet);
    print $fh "\0" x 2;
  }

} # end subroutine _write_binary definition
########################################################################

=head2 _write_ascii

  $self->_write_ascii($filehandle);

=cut

sub _write_ascii {
  my $self = shift;
  my ($fh) = @_;

  my $spaces = '';
  my $print = sub {print $fh $spaces, @_, "\n"};
  my @parts = $self->parts or croak("no parts to write");
  foreach my $part (@parts) {
    $print->('solid ', $part->name);
    $spaces = ' 'x2;
    foreach my $facet ($part->facets) {
      my ($n, @pts) = @$facet;
      $print->(join(' ', 'facet normal', @$n));
      $spaces = ' 'x4;
      $print->('outer loop');
      $spaces = ' 'x6;
      (@pts == 3) or die "invalid facet";
      foreach my $pt (@pts) {
        $print->(join(' ', 'vertex', @$pt));
      }
      $spaces = ' 'x4;
      $print->('endloop');
      $spaces = ' 'x2;
      $print->('endfacet');
    }
    $spaces = '';
    print $fh 'endsolid ', $part->name, "\n";
  }
} # end subroutine _write_ascii definition
########################################################################

=head1 AUTHOR

Eric Wilhelm @ <ewilhelm at cpan dot org>

http://scratchcomputing.com/

=head1 BUGS

If you found this module on CPAN, please report any bugs or feature
requests through the web interface at L<http://rt.cpan.org>.  I will be
notified, and then you'll automatically be notified of progress on your
bug as I make changes.

If you pulled this development version from my /svn/, please contact me
directly.

=head1 COPYRIGHT

Copyright (C) 2007 Eric L. Wilhelm, All Rights Reserved.

=head1 NO WARRANTY

Absolutely, positively NO WARRANTY, neither express or implied, is
offered with this software.  You use this software at your own risk.  In
case of loss, no person or entity owes you anything whatsoever.  You
have been warned.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# vi:ts=2:sw=2:et:sta
1;
package CAD::Format::STL::part;
$VERSION = v0.2.1;

use warnings;
use strict;
use Carp;

=head1 NAME

CAD::Format::STL::part - guts of the STL object

=head1 SYNOPSIS

See L<CAD::Format::STL>

=cut

use Class::Accessor::Classy;
rw 'name';
lw 'facets';
no  Class::Accessor::Classy;

=head1 Constructor

=head2 new

  my $part = CAD::Format::STL::part->new($name, @facets);

=cut

sub new {
  my $package = shift;
  my ($name, @facets) = @_;

  my $class = ref($package) || $package;
  my $self = {
    name => (defined($name) ? $name : 'CAD::Format::STL part'),
    facets => [],
  };
  bless($self, $class);

  $self->add_facets(@facets) if(@facets);

  return($self);
} # end subroutine new definition
########################################################################

=head2 add_facets

  $self->add_facets(@facets);

Facets are stored with the normal vector, followed by vertices.
Typically, a single facet is a triangle and the normal is [0,0,0]
(meaning that it should be calculated by the user if needed.)

  [0,0,0], [0,0,0],[0,1,0],[1,1,0]

=cut

sub add_facets {
  my $self = shift;
  my (@facets) = @_;

  foreach my $facet (@facets) {
    my @pts = @$facet;
    my $n = ((scalar(@pts) == 3) ? [0,0,0] : shift(@pts));
    $self->SUPER::add_facets([$n, @pts]);
  }
} # end subroutine add_facets definition
########################################################################

=head1 AUTHOR

Eric Wilhelm @ <ewilhelm at cpan dot org>

http://scratchcomputing.com/

=head1 BUGS

If you found this module on CPAN, please report any bugs or feature
requests through the web interface at L<http://rt.cpan.org>.  I will be
notified, and then you'll automatically be notified of progress on your
bug as I make changes.

If you pulled this development version from my /svn/, please contact me
directly.

=head1 COPYRIGHT

Copyright (C) 2007 Eric L. Wilhelm, All Rights Reserved.

=head1 NO WARRANTY

Absolutely, positively NO WARRANTY, neither express or implied, is
offered with this software.  You use this software at your own risk.  In
case of loss, no person or entity owes you anything whatsoever.  You
have been warned.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# vi:ts=2:sw=2:et:sta
1;
#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
import Pngcam::Render;

my $width;
my $height;
my $border = 32; # px
my $bottom;
my $png;
my $rgb;

my $quiet;

GetOptions(
    'border=f' => \$border,
    'width=f' => \$width,
    'height=f' => \$height,
    'bottom' => \$bottom,
    'png=s' => \$png,
    'rgb' => \$rgb,

    'quiet' => \$quiet,

    'help' => sub { help() },
    'usage' => sub { help() },
) or help();

help() if @ARGV != 1;
my $stl_file = shift @ARGV;

$png ||= "$stl_file.png";
$width = 400 if !defined $width && !defined $height;

my $render = Pngcam::Render->new(
    stl_file => $stl_file,

    border => $border,
    width => $width,
    height => $height,
    bottom => $bottom,
    rgb => $rgb,

    quiet => $quiet,
);
$render->run;
$render->save($png);

sub help {
    print qq{Usage: pngcam-render [options] STLFILE

This program will read in the STLFILE and render it to a heightmap.

Options:

    --border PX
        Draw a border around the part.
        Default: 32

    --width PX
        Set the width of the part in pixels. If height is not specified, height will be calculated
        automatically to maintain aspect ratio. If neither are specified, width=400px is assumed.
        The output image will be this wide, plus a border on both sides.
        Default: 400

    --height PX
        Set the height of the part in pixels. If width is not specified, width will be calculated
        automatically to maintain aspect ratio. If neither are specified, width=400px is assumed.
        The output image will be this talg, plus a border on both sides.
        Default: N/A

    --bottom
        View from the bottom, as if the part were rotated through 180 degrees around the Y axis.
        Default: viewed from the top

    --png PNGFILE
        Set the name of the output file. If none is give, this will just be the STL file with ".png" appended.
        Default: STLFILE.png

    --rgb
        Use R,G,B channels independently to get 24 bits of height data instead of 8.
        Default: greyscale

    --quiet
        Suppress output of dimensions, resolutions, and progress.

Pngcam-render is a program by James Stanley. You can email me at james\@incoherency.co.uk or read my blog at https://incoherency.co.uk/
};

    exit 0;
}
